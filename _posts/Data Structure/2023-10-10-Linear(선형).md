---
title: "Linear(선형)"
categories: DataStructures
---

- 원소들을 순차적으로 나열 시키며 앞 뒤 관계가 1:1

## Contiguous Data Structures(연속된 자료 구조)
![연속된 자료구조]({{site.url}}/images/ContiguousDataStructures.png)
- 대표적으로 array가 있음
- 모든 원소를 단일 메모리 Chunk에 저장함
- 각각의 원소는 같은 Data Type을 사용하고 같은 크기의 메모리를 사용함
- 첫번째 원소의 주소를 Base Address(BA)
- 배열의 전체 크기와 상관없이 모든 원소에 곧바로 접근할 수 있어서 데이터 접근 시간이 항상 일정( O(1) )
- 배열에는 Static array(정적 배열), Dynamic array(동적 배열)이 있음
- 정적 배열은 Stack 메모리 영역에 할당되기 때문에 함수를 벗어나면 자동으로 해제됨
- 동적 배열은 Heap 영역에 할당되며 사용자가 직접 해제하기 전까지 유지됨
- 배열같은 연속된 자료 구조는 서로 인접해 있기 때문에 원소에 접근할 때 그 옆에 있는 원소의 Cache로 가져옴
- 이를 Cache Locality(캐시 지역성)이라고 하며 시간 복잡도에는 영향을 주지 않음? 
```cpp
int arr[size]   // 정적 배열 선언
int* arr = (int*)malloc(size * sizeof(int));    // C 동적 배열 선언
int* arr = new int[size];   // C++ 동적 배열 선언
```  

<br />

## Linked Data Structures(연결된 자료 구조)
![연결된 자료구조]({{site.url}}/images/LinkedDataStructures.png)
- 대표적으로 list가 있음
- Node라고 하는 여러 개의 메모리 Chunk에 데이터를 저장하며 서로 다른 메모리에 데이터가 저장됨
- 각각 노드에 저장할 데이터(data)와 다음 노드를 가리키는 포인터(next)를 가짐
- 맨 마지막 노드는 포인터 대신 자료 구조의 끝을 나타내는 NULL을 가짐
- 특정 원소에 접근하려면 리스트의 시작 부분(head)에서 next 포인터를 따라 차례차례 이동해야함
- 그러므로 원소 접근 시간은 노드 개수에 비례하며 시간 복잡도는 O(n)
- 배열과 달리 연결리스트는 원소의 삽입과 삭제를 빠르게 수행할 수 있음

<br />

### 연결리스트 새 원소 추가
![연결 리스트 원소 추가]({{site.url}}/images/LinkedList_add.png)
1. 새로운 원소를 삽입하기 위해 새로운 노드 생성
2. 새로 추가한 노드의 next 포인터가(2번째 next) 다음 노드를(3번째 data)를 가리킴
3. 이전 노드의 next 포인터가(1번째 next) 다음 노드(3번째 data)를 가리켰던것을 제거하고 새로운 노드(2번째 data)를 가르킴
4. 새로운 노드가 연결 리스트에 추가됨
- 기존원소의 삭제도 이것과 비슷한 방식으로 진행됨 

<br />

## 연속된 자료구조 연결된 자료구조 비교
|연속된 자료구조|연결된 자료구조|
|---|---|
|모든 데이터가 메모리에 연속으로 저장|데이터는 노드에 저장되고 노드는 메모리 곳곳에 흩어져 있음|
|임의 원소에 즉시 접근 가능|임의 원소에 접근하는것은 선형 시간 복잡도를 가지며 느린편|
|데이터가 연속적이기 때문에 캐시 지역성 효과로 데이터 순회가 빠름|캐시 지역성이 없으므로 모든 데이터를 순회하는 것이 느린편|
|데이터 저장을 위해 데이터 크기만큼의 메모리 사용|각 노드에서 포인터 저장을 위해 여분의 메모리 사용|
<br />

### 배열과 연결리스트 시간 복잡도
|파라미터|배열|연결 리스트|
|---|:---:|:---:|
|임의 접근|O(1)|O(n)|
|맨 뒤에 원소 삽입|O(1)|O(1)|
|중간에 원소 삽입|O(n)|O(1)|
|캐시 지역성|있음|없음|
<br />
