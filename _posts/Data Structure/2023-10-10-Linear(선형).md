---
title: "Linear(선형)"
categories: DataStructures
---

- 원소들을 순차적으로 나열 시키며 앞 뒤 관계가 1:1

## Contiguous Data Structures(연속된 자료 구조)
![연속된 자료구조]({{site.url}}/images/ContiguousDataStructures.png)
- 대표적으로 array가 있음
- 모든 원소를 단일 메모리 Chunk에 저장함
- 각각의 원소는 같은 Data Type을 사용하고 같은 크기의 메모리를 사용함
- 첫번째 원소의 주소를 Base Address(BA)
- 배열의 전체 크기와 상관없이 모든 원소에 곧바로 접근할 수 있어서 데이터 접근 시간이 항상 일정( O(1) )
- 배열에는 Static array(정적 배열), Dynamic array(동적 배열)이 있음
- 정적 배열은 Stack 메모리 영역에 할당되기 때문에 함수를 벗어나면 자동으로 해제됨
- 동적 배열은 Heap 영역에 할당되며 사용자가 직접 해제하기 전까지 유지됨
- 배열같은 연속된 자료 구조는 서로 인접해 있기 때문에 원소에 접근할 때 그 옆에 있는 원소의 Cache로 가져옴
- 이를 Cache Locality(캐시 지역성)이라고 하며 시간 복잡도에는 영향을 주지 않음? 
```cpp
int arr[size]   // 정적 배열 선언
int* arr = (int*)malloc(size * sizeof(int));    // C 동적 배열 선언
int* arr = new int[size];   // C++ 동적 배열 선언
```  

<br />

## Linked Data Structures(연결된 자료 구조)
![연결된 자료구조]({{site.url}}/images/LinkedDataStructures.png)
- 대표적으로 list가 있음
- Node라고 하는 여러 개의 메모리 Chunk에 데이터를 저장하며 서로 다른 메모리에 데이터가 저장됨
- 각각 노드에 저장할 데이터(data)와 다음 노드를 가리키는 포인터(next)를 가짐
- 맨 마지막 노드는 포인터 대신 자료 구조의 끝을 나타내는 NULL을 가짐
- 특정 원소에 접근하려면 리스트의 시작 부분(head)에서 next 포인터를 따라 차례차례 이동해야함
- 그러므로 원소 접근 시간은 노드 개수에 비례하며 시간 복잡도는 O(n)
- 배열과 달리 연결리스트는 원소의 삽입과 삭제를 빠르게 수행할 수 있음

<br />

### 연결리스트 새 원소 추가
![연결 리스트 원소 추가]({{site.url}}/images/LinkedList_add.png)
1. 새로운 원소를 삽입하기 위해 새로운 노드 생성
2. 새로 추가한 노드의 next 포인터가(2번째 next) 다음 노드를(3번째 data)를 가리킴
3. 이전 노드의 next 포인터가(1번째 next) 다음 노드(3번째 data)를 가리켰던것을 제거하고 새로운 노드(2번째 data)를 가르킴
4. 새로운 노드가 연결 리스트에 추가됨
- 기존원소의 삭제도 이것과 비슷한 방식으로 진행됨 

<br />

## 연속된 자료구조 연결된 자료구조 비교
|연속된 자료구조|연결된 자료구조|
|---|---|
|모든 데이터가 메모리에 연속으로 저장|데이터는 노드에 저장되고 노드는 메모리 곳곳에 흩어져 있음|
|임의 원소에 즉시 접근 가능|임의 원소에 접근하는것은 선형 시간 복잡도를 가지며 느린편|
|데이터가 연속적이기 때문에 캐시 지역성 효과로 데이터 순회가 빠름|캐시 지역성이 없으므로 모든 데이터를 순회하는 것이 느린편|
|데이터 저장을 위해 데이터 크기만큼의 메모리 사용|각 노드에서 포인터 저장을 위해 여분의 메모리 사용|
<br />

### 배열과 연결리스트 시간 복잡도
|파라미터|배열|연결 리스트|
|---|:---:|:---:|
|임의 접근|O(1)|O(n)|
|맨 뒤에 원소 삽입|O(1)|O(1)|
|중간에 원소 삽입|O(n)|O(1)|
|캐시 지역성|있음|없음|
<br />


## std::array
- memory를 자동으로 할당하고 해제함
- 원소의 타입과 배열 크기를 매개변수로 사용하는 클래스 템플릿
- C와 마찬가지로 원소에 접근할 수 있는 [] 연산자를 제공
- 빠른 동작을 위해 전달된 인덱스 값이 배열 크기보다 작은지 검사하지 않음
- 대신 at(index) 함수를 사용하면 유효하지 않는 값이 들어오면 out of range 예외를 발생시킴
- 배열 인덱스를 사용자 입력으로 받는다거나 다른 이유로 인해 유효하지 않은 인덱스에 접근할 때 예최 처리 코드를 만들 수 있음
```cpp
int main() {
    array<int, 4> arr = {1,2,3,4};
    
    try {
        cout << arr.at(3) << endl;
        cout << arr.at(4) << endl;
    } catch (const out_of_range& ex) {
        cerr << ex.what() << endl;
    }
}
// 4
// array::at: __n (which is 4) >= _Nm (which is 4) 출력
```

- array는 객체를 다른 함수에 전달하는 방식은 기본 데이터 타입을 전달하는 것과 유사
- 값 또는 참조(reference)로 전달할 수 있고 const를 함께 사용할 수 있음
- 포인터 연산을 사용한다거나 참조 또는 역참조(de-reference) 연산을 하지 않아도 됨
- 그러므로 다차원 배열을 전달하는 경우 array를 사용하는 것이 가독성이 좋음

```cpp
void print(array<int ,5> arr) {
        for(auto ele: arr)
            cout << ele << ", ";
}

int main() {
    array<int, 5> arr = {1, 2, 3, 4, 5};
    print(arr);
}
// 1, 2, 3, 4, 5, 출력
```
- 사용자 정의 함수 print()에 array 배열을 값으로 전달하는 예제 코드
- 예시는 배열의 크기가 고정되어 있어서 다른 크기의 배열을 전달 할 수 없음
- 동적인 배열 출력을 만들고 싶다면 print() 함수 템플릿을 선언하고 배열 크기를 템플릿 매개변수로 전달하면 됨
```cpp
template <size_t N>
void print(const array<int,N>& arr) {
        for(auto ele: arr)
            cout << ele << ", ";
}
```
- array는 객체를 전달할 때 새로운 배열에 모든 원소가 복사됨 (자동으로 깊은 복사)
- 이러한 동작을 피하고 싶다면 참조 또는 const 참조를 사용하면 됨



- for 반복문을 통해 원소들을 차례대로 접근할 수 있지만 반복자( begin(), end() )를 통해서도 접근 가능
- 반복자를 사용함으로써 코드의 재사용성, 유지보수, 가독성의 이점을 얻을 수 있음
- array, vector, map, set, list처럼 반복 가능한 모든 STL(Standard Template Library)컨테이너에 대해 사용할 수 있음
- C++ 반복자를 이용하여 범위를 지정하는 함수들은 보통 start()가 반환하는 반복자는 범위에 포함되고 따로 명시하지 않았다면 end()가 반환하는 반복자는 범위에 포함하지 않음
- 범위 기반 반복문은 다음과 같이 바꿔 사용할 수 있음

```cpp
for(auto it = arr.begin(); it != arr.end(); it++) {
    auto element = (*it);
    cout << element << ' ';
}
```

- const_iterator 또는 reverse_iterator 유형의 반복자도 사용할 수 있음
- const로 선언된 배열에 begin(), end() 같은 함수를 사용하면 const_iterator를 반환

원소 접근 함수
front() 배열의 첫 번쨰 원소에 대한 참조 반환
back()  배열의 마지막 원소에 대한 참조 반환
data()  배열 객체 내부에서 실제 데이터 메모리 버퍼를 가리키는 포인터를 반환
```cpp
array<int, 5> arr = {1, 2, 3, 4, 5};
cout << arr.front();        // 1
cout << arr.back();         // 5
cout << *(arr.data() + 1);  // 2
```
- array는 깊은 비교(deep comparison)을 위한 관계 연산자(relational operator)와 깊은 복사를 위한 복사 할당 연산자(copy-assignment operator)를 지원함
- C 스타일 배열에서도 관계 연산자를 사용할 수 있지만 원소값을 비교하는 것이 아닌 포인터 주소 값을 비교
- 즉 깊은 비교 대신 얕은 비교(shallow comparison)를 수행하기 때문에 실용적이지 않음
- 할당(assignment)에 대해서도 새로 생성하여 값을 복사하지 않으며, 단순히 같은 배열 데이터를 가리키는 새로운 포인터를 생성할 뿐임

- std::array는 크기가 데이터 타입 일부로 동작하기 때문에 관계 연산자를 사용할 경우 비교할 두 배열의 크기가 같아야 함 
