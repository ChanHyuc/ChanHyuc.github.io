---
title: "CPU 성능 향상 기법"
categories: ComputerArchitecture
---
## Clock(클럭)
- 클럭 신호가 빠르게 반복되면 CPU와 그 외의 부품들은 꼭 그런건 아니지만 일반적으로 빠른 박자로 움직임
- 즉 클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복함
- 클럭 속도가 높은 CPU는 일반적으로 성능이 좋고 그래서 클럭 속도는 CPU 속도 단위로 간주됨
- 클럭 속도는 헤르츠(Hz) 단위로 측정, 1초에 클럭이 몇 번 반복되는지 나타냄 ex) 2.5GHz = 25억번
- 클럭 속도는 고성능을 요구할 때 클럭 속도를 높이고 그렇지 않을 때는 낮추기도 함
- 최대 클럭 속도를 강제로 끌어올릴 수 있는 데 이런 기법을 **overcloking**이라고 함
- 고성능 작업을 장시간 할 경우 발열 문제가 심각해짐

## Core
- CPU에서 명령어를 실행하는 부품
- 클럭 속도를 높여서 CPU 성능을 올리는 방법에는 한계가 있음
- 그래서 현실적인 방법으로 CPU의 Core나 Thread를 늘리는 방법이 있음 ex) 8코어: 명령어를 실행하는 부품인 Core가 8개 있는 것
- Core가 하나만 있는것은 SingleCore, 2개 이상 여러개가 있는것을 MultiCore
- Core가 아무리 많아도 적절하게 명령어가 분배되지 않는다면 연산 속도가 증가 하지 않음
- 또한 작업량에 비해 Core수가 지나치게 많아도 유의미한 성능 변화가 없음

## Thread
- 사전적인 의미로 '실행 흐름의 단위'

### 하드웨어적 스레드 / Logical Processor(논리 프로세서)
- CPU에서 사용
- 논리 프로세서: 실제 프로세서의 갯수는 아니지만 메모리가 실행되고 있는 프로그램이 몇개 인가 하드웨어 스레드 개수만큼 있음
- 하나의 코어가 동시에 처리하는 명령어 단위
- 하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 MultiThread라고 함
- Hyper-Threading: Intel사의 MultiThread 기술
- 가장 큰 핵심은 레지스터
- 하나의 코어로 여러 명령어를 동시에 처리할 경우 하나의 명령어를 처리하기 위해 꼭 필요한 레지스터를 여러개를 가지면 됨
    - 프로그램 카운터
    - 스택 포인터
    - 데이터 버퍼 레지스터
    - 데이터 주소 레지스터
    
### 소프트웨어적 스레드
- 프로그램에서 사용
- 1코어 1스레드 CPU도 **여러개의 소프트웨어적 스레드**를 만들 수 있음
- 1코어 1스레드는 실제로 동시에 작업하는게 아닌 매우 빠른속도로 번갈아 가면서 실행하기 때문에 동시에 작업하는것처럼 보임
- 하나의 프로그램에서 독립적으로 실행되는 단위
- 하나의 프로그램에서 한개씩 실행할 수 있지만 여러 스레드를 사용할 경우 여러 부분을 동시에 실행할 수도 있음

![]({{site.url}}/images/CoreThread.png)
**멀티코어 프로세서**: 명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 두 개 이상 있는 CPU
**멀티스레드 프로세서**: 하나의 코어로 여러개의 명령어를 동시에 실행할 수 있는 CPU

## ILP(Instruction-Level Parallelism, 명령어 병렬 처리 기법)
- 빠른 CPU를 만들기 위해 높은 클럭속도, 코어와 스레드의 숫자도 중요하지만 CPU가 놀지 않고 효율적으로 작동하게 만드는것도 중요

### Instruction Pipelining(명령어 파이프라이닝)
- 명령어 처리 과정을 클럭 단위로 나누면 (이 단계가 명확하게 정답은 아님, 전공서마다 단계를 나누는게 다르기도 함)
1. Instruction Fetch(명령어 인출)
2. Instruction Decode(명령어 해석)
3. Execute Instruction(명령어 실행)
4. Write Back(결과 저장)
- 동시에 여러 개의 명령어를 겹처 실행하는 기법
- 중요한 것은 단계만 겹치지 않는다면 **각 단계를 동시에 실행할 수 있음**
- ex) A라는 명령어가 인출을 하고 있을 때 B명령어는 해석을 할 수 있고 C명령어는 실행할 수 있음
- 마치 공장 생산 라인과 같음
- 높은 성능을 가져오지만 특정 상황에서 성능 향상에 실패하는 경우도 있음(Pipeline Hazard, 파이프라인 위험)

## Pipeline Hazard(파이프라인 위험)
1. Data Hazard(데이터 위험)
- 명령어 간 '데이터 의존성'에 의해 발생
- ex) 명령어1: R1 <- R2 + R3 // R2 레지스터 값과 R3 레지스터 값을 더한 값을 R1에 저장
- ex) 명령어2: R4 <- R1 + R5 // R1 레저스터 값과 R5 레지스터 값을 더한 값을 R4에 저장
명령어 1을 실행하고 결과값이 저장되고 나서 명령어 2를 실행해야 함
명령어 1의 결과값이 인출되기 전에 명령어 2를 실행할 경우 예기치 못한 결과값이 나올 수 있음(R2는 R1 값이 꼭 필요하므로)
이런 상황을 명령어 2는 명령어 1의 데이터에 의존한다고 함
이처럼 의존적인 두 명령어를 무작정 동시에 실행할 경우 제대로 작동하지 않을 수 있음

2. Control Hazard(제어 위험)
- 분기 등으로 **프로그램 카운터의 예기치못한 변화**에 의해 발생
- 일반적으로 프로그램 카운터는 **현재 실행중인 명령어의 다음 주소**로 갱신됨
- 하지만 분기에 의해 실행 흐름이 바뀌어 변화가 생긴다면 파이프라인에 미리 가지고 와서 처리중이던 명령어들이 쓸모 없어질 수 있음
- 이를 위해 사용하는 기술이 breanch prediction(분기 예측), 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술 

3. Structural Hazard(구조적 위험) / Resource Hazard(자원 위험)
- 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같이 CPU를 사용하려 할 때

## SuperScalar(슈퍼스칼라)
- 오늘날 대부분의 CPU는 여러개의 파이프라인을 사용
- 이론적으로는 파이프라인 개수에 비례해서 프로그램 처리 속도가 빨라져야 되지만, 파이프라인 위험 때문에 개수에 비례해서 빨라지지 않음
- 이 때문에 슈퍼스칼라는 파이프라인 위험을 방지하기 위해 고도로 설계되어야 함


## Reference
[혼자 공부하는 컴퓨터구조]()
