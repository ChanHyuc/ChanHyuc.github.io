---
title: "CPU 성능 향상 기법"
categories: ComputerArchitecture
---
## Clock(클럭)
- 클럭 신호가 빠르게 반복되면 CPU와 그 외의 부품들은 꼭 그런건 아니지만 일반적으로 빠른 박자로 움직임
- 즉 클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복함
- 클럭 속도는 **헤르츠(Hz)** 단위로 측정, 1초에 클럭이 몇 번 반복되는지 나타냄 ex) 2.5GHz = 25억번
- 클럭 속도는 고성능을 요구할 때 클럭 속도를 높이고 그렇지 않을 때는 낮추기도 함
- 고성능 작업을 장시간 할 경우 발열 문제가 심각해짐 (클럭속도를 높이는것 만으로는 CPU 성능을 올리는데 한계가 있음)
- overcloking: 최대 클럭 속도를 강제로 끌어올릴 수 있는 기법

## Core
- CPU에서 명령어를 실행하는 부품
- Core나 Thread를 늘려 CPU 성능을 향상 시킬 수 있음 ex) 8코어: 명령어를 실행하는 부품인 Core가 8개 있는 것
- MultiCore: 명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 두 개 이상 있는 CPU
- Core가 아무리 많아도 적절하게 명령어가 분배되지 않는다면 연산 속도가 증가 하지 않음
- 또한 작업량에 비해 Core수가 지나치게 많아도 유의미한 성능 변화가 없음

![]({{site.url}}/images/ComputerArchitecture/CoreThread.png)

## Thread
- 실행 흐름의 단위

### 하드웨어적 스레드 / Logical Processor(논리 프로세서)
- 하나의 코어가 동시에 처리하는 명령어 단위
- MultiThread: 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
- Hyper-Threading: Intel사의 MultiThread 기술
- 하나의 코어로 여러 명령어를 동시에 처리할 경우 하나의 명령어를 처리하기 위해 꼭 필요한 레지스터를 여러개를 가지면 됨
- ex) 프로그램 카운터, 스택 포인터, 데이터 버퍼 레지스터, 데이터 주소 레지스터
    
### 소프트웨어적 스레드
- 하나의 프로그램에서 독립적으로 실행되는 단위
- 1코어 1스레드 CPU도 **여러개의 소프트웨어적 스레드**를 만들 수 있음
- 1코어 1스레드는 실제로 동시에 작업하는게 아닌 매우 빠른속도로 번갈아 가면서 실행하기 때문에 동시에 작업하는 것처럼 보임


## ILP(Instruction-Level Parallelism, 명령어 병렬 처리 기법)
- 빠른 CPU를 만들기 위해 높은 클럭속도, 코어와 스레드의 숫자도 중요하지만 CPU가 놀지 않고 효율적으로 작동하게 만드는것도 중요

### Instruction Pipelining(명령어 파이프라이닝)
1. Instruction Fetch(명령어 인출)
2. Instruction Decode(명령어 해석)
3. Execute Instruction(명령어 실행)
4. Write Back(결과 저장)
- 동시에 여러 개의 명령어를 겹처 실행하는 기법(마치 공장 생산 라인과 같음)
- 겹치지 않는다면 **각 단계를 동시에 실행할 수 있음**
- ex) A라는 명령어가 인출을 하고 있을 때 B명령어는 해석을 할 수 있고 C명령어는 실행할 수 있음
- 높은 성능을 가져오지만 특정 상황에서 성능 향상에 실패하는 경우도 있음(Pipeline Hazard, 파이프라인 위험)

### Pipeline Hazard(파이프라인 위험)
1. Data Hazard(데이터 위험)
- 명령어 간 '데이터 의존성'에 의해 발생
- 명령어1: R1 <- R2 + R3 // R2 레지스터 값과 R3 레지스터 값을 더한 값을 R1에 저장
- 명령어2: R4 <- R1 + R5 // R1 레저스터 값과 R5 레지스터 값을 더한 값을 R4에 저장
        - 명령어 1을 실행하고 결과값이 저장되고 나서 명령어 2를 실행해야 함
        - 명령어 1의 결과값이 인출되기 전에 명령어 2를 실행할 경우 **예기치 못한 결과값**이 나올 수 있음(R2는 R1 값이 꼭 필요하므로)
        - 명령어 2는 명령어 1의 데이터에 **의존**
        - **의존적인** 두 명령어를 무작정 동시에 실행할 경우 제대로 작동하지 않을 수 있음

2. Control Hazard(제어 위험)
- 분기 등으로 **프로그램 카운터의 예기치못한 변화**에 의해 발생
- 일반적으로 프로그램 카운터는 **현재 실행중인 명령어의 다음 주소**로 갱신됨
- 하지만 분기에 의해 실행 흐름이 바뀌어 변화가 생긴다면 파이프라인에 미리 가지고 와서 처리중이던 명령어들이 쓸모 없어질 수 있음
- 이를 위해 사용하는 기술이 **breanch prediction(분기 예측)**, 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술 

3. Structural Hazard(구조적 위험) / Resource Hazard(자원 위험)
- 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같이 CPU를 사용하려 할 때

### SuperScalar(슈퍼스칼라)
- 오늘날 대부분의 CPU는 여러개의 파이프라인을 사용
- 이론적으로는 파이프라인 개수에 비례해서 프로그램 처리 속도가 빨라져야 되지만, 파이프라인 위험 때문에 개수에 비례해서 빨라지지 않음
- 슈퍼스칼라는 파이프라인 위험을 방지하기 위해 고도로 설계되어야 함

### Out-Of-Order Execution(비순차적 명령어 처리)
- 명령어들을 비순차적으로 실행하는 기법
- 파이프라인, 슈퍼스칼라는 프로그램을 위에서 아래로 차례대로 실행하는 방식
- 명령어를 순차적으로 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 파이프라인이 멈추는것을 방지


## Instruction Set(명령어 집합, ISA(Instruction Set Architecture) )
- CPU가 이해할 수 있는 명령어들의 모음
- CPU마다 ISA가 다르기 때문에 명령어가 다르고 서로의 명령어를 읽을 수 없음(어셈블리어가 달라짐)
    - ex) Intel CPU 컴퓨터에서 만든 실행파일을 아무 설정없이 그대로 ARM이 탑재된 아이폰에 가져올 경우 실행이 안됨
- 똑같은 CPU여도 다른 컴파일러를 사용하면 어셈블리어가 달라짐

### CISC(Complex Instruction Set Computer)
- 명령어의 형태와 크기가 다양한 **가변 길이 명령어**를 사용
- 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있기 때문에 메모리 공간을 절약할 수 있음
- 활용하는 명령어가 복잡하기 때문에 명령어의 크기와 실행되기까지의 시간이 일정치 않은 단점이 있음
- 명령어가 **일정하지 않기 때문**에 명령어 파이프라인에서 효율적으로 동작하기 힘듦
- 다양한 명령어를 지원하지만 대다수의 명령어는 사용 빈도가 낮음 (사용하는것만 사용함)

### RISC(Reduced Instruction Set Computer)
- 명령어의 종류가 적고 CISC와 달리 짧고 규격화 됨(고정 길이 명령어)
- 하나의 명령어가 1클럭 내외로 실행되기 때문에 RISC는 명령어 파이프라이닝에 최적화 됨
- 메모리 접근을 단순, 최소화(load, store) 하는 대신 레지스터를 적극적으로 활용

|CISC|RISC|
|---|---|
|복잡하고 다양한 명령어|단순하고 적은 명령어|
|가변 길이 명령어|고정 길이 명령어|
|다양한 주소 지정|적은 주소 지정|
|프로그램을 이루는 명령어의 수가 적음|프로그램을 이루는 명령어의 수가 많음|
|여러 클럭을 거쳐서 수행|1클럭 내외로 수행|
|파이프라이닝하기 어려움|파이프라이닝에 최적화|

## Reference
[혼자 공부하는 컴퓨터구조]()
