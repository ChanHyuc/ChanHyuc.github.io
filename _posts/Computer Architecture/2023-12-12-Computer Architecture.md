---
title: "Computer Architecture"
categories: ComputerArchitecture
---
## Computer Architecture(컴퓨터 구조)
- 컴퓨터의 구성요소나 작동원리를 몰라도 프로그래밍 문법만 알면 개발을 하는데 전혀 지장이 없음
- 때문에 '개발자면 코드만 잘 설계하면 되는거 아닌가?' 라는 의문을 가질 수 있음
- 하지만 좋은 개발자가 되려면 프로그래밍 언어의 문법과 함께 **컴퓨터의 근간**(컴퓨터구조, 운영체제)을 알아야 함
- 문제 해결 능력을 기를 수 있음
    - 똑같은 코드를 작성했지만 실행하는 컴퓨터에 따라서 실행이 되거나 에러가 생길 수 있음 (빈번함)
    - 내가 작성한 코드가 내 컴퓨터에서는 작동이 되었지만 배포후에 다른 사람 컴퓨터에서는 작동이 안될 수도 있음
    - 컴퓨터 구조를 이해하면 문제 상황을 빠르게 진단하고 다양한 문제 해결방법을 찾을 수 있음
- 성능, 용량, 비용을 고려한 개발을 할 수 있음
    - 내가 지금 개발한 코드가 얼만큼의 성능을 가진 컴퓨터를 필요로 하는지를 개발자 스스로 판단할 수 있어야함
    - 클라우드 서비스를 이용하더라도 CPU, 메모리, 저장용량등은 직접 선택해야함

# 2강

## 컴퓨터가 이해하는 정보
### 데이터
- 숫자, 문자, 이미지, 동영상과 같은 정적인 정보
- 컴퓨터 내부에 저장된 정보를 데이터라고도 함
- 데이터는 명령어 없이는 아무것도 할 수 없는 정보 덩어리일 뿐

### 명령어
- 데이터를 움직이고 컴퓨터를 실질적으로 작동시킴.
ex) 4와 11을 더하라  // 4와 11은 데이터, 더하라는 명령어

## 컴퓨터의 네 가지 핵심 부품
- 라즈베리파이, 아두이노, 스마트폰, 노트북, 서버컴퓨터 등 다양한 종류의 컴퓨터가 있음
- 하지만 핵심 부품인 4가지는 공통적으로 가지고 있음
- 컴퓨터 부품끼리 서로 정보를 주고 받기 위한 통로를 Bus
- 다양한 Bus들이 있지만 컴퓨터의 네 가지 핵심부품끼리 정보를 주고받는 가장 중요한 Bus를 시스템 Bus

### 메인보드
- 메인보드에 연결된 부품은 버스를 통해 정보를 주고 받음
- 컴퓨터의 네 가지 핵심 부품을 연결하는 버스가 System Bus(시스템 버스)

### 시스템 버스
- 주소 버스: 주소를 주고받음
- 데이터 버스: 데이터와 명령어를 주고받음
- 제어 버스: 제어 신호를 주고받음

1. CPU (Central Processing Unit)
- 메모리에 저장된 명령어를 읽고 해석하고 실행함
- ALU(Arithmetic and Logical Unit, 산술연산장치): 계산만 함, 컴퓨터의 대부분 계산을 함
- Control Unit(제어장치): 제어 신호(메모리 읽기 / 메모리 쓰기)를 주거나 받고, 명령어를 해석
- Register: CPU 안의 작은 저장장치, CPU안에 여러 레지스터가 있고 각자 다른 이름과 역할이 있음

2. Main Memory(주 기억장치)
- 프로그램(데이터, 명령어)이 실행되기 위해서는 메모리에 저장되어 있어야함
- 메모리는 Process(현재 실행되는 프로그램)의 명령어와 데이터를 저장함
- 메모리에 저장된 값의 위치는 주소로 알 수 있음 

3. Secondary Storage (보조기억장치)
- Memory(주 기억 장치)는 가격이 비싸고 전원이 꺼지면 저장된 내용이 사라짐(휘발성)
- 보조기억장치는 전원이 꺼져도 프로그램(데이터, 명령어)을 저장함(비휘발성)

4. input/ouput (I/O)Device(입출력장치)
- 컴퓨터 외부와 내부를 연결하여 정보를 교환함



- character set(문자 집합): 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
- character Encoding(문자 인코딩): 문자 집합에 있는 문자를 Encoding 과정을 거쳐 컴퓨터가 이해할 수 있는 0과 1로 이루어진 문자 코드가 됨
- character Decoding(문자 디코딩): 반대로 컴퓨터가 이해할 수 있는 0과 1로 이루어진 문자코드를 사람이 읽을 수 있는 문자로 변환하는 과정

## ASCII(아스키 코드)
- 초창기 문자 집합 중 하나로 영어, 숫자, 일부 특수문자 포함
- 하나의 아스키 문자를 위해 8bit(1byte)를 사용하는데 1bit는 Parity bit로 오류 검출을 위해 사용됨
- 때문에 실질적으로 7bit로 표현할 수 있고 7비트로 표현할 수 있는 정보의 가짓수는 128개

## EUC-KR
- 한글 전용 인코딩
- 완성형 인코딩으로 초성, 중성, 종성의 조합으로 이루어진 하나의 완성된 글자에 고유한 코드를 부여
- 한글 단어 하나에 2byte 크기의 코드 부여
- 2350개 정도의 한글을 표현할 수 있지만 부족함

## Unicode(유니코드)
- 대부부의 나라의 문자, 특수문자, 이모티콘 까지 코드로 표현할 수 있는 통일된 문자 집합
- 글자에 부여된 값 자체를 인코딩된 값으로 정하지 않고 이 값을 다양한 방법으로 인코딩 함
- 종류로는 UTF-8, UTF-16, UTF-32 등이 있음 각각 인코딩 하는 방식
- 가장 대중적으로 UTF-8을 사용함

# 6강
## high-level Programming language(고급언어)
- 사람이 이해하기 쉽게 만들어진 언어
- 대부분의 프로그래밍 언어

## low-level Programming language(저급언어)
- 컴퓨터가 직접 이해하고 실행할 수 있는 언어
- 기계어와 어셈블리어가 있음
- 하드웨어와 밀접하게 맞닿은 프로그램을 개발하는 임베디드 개발자, 게임 개발자, 보안 솔루션 개발자, 시스템 해커 등에서 어셈블리어를 많이 사용
- 어셈블리어를 읽으면 컴퓨터가 프로그램을 어떤 과정으로 실행하는지 어떤 절차로 작동하는지 근본적인 단계부터 추적하고 관찰할 수 있음
- 어셈블리어는 CPU마다 컴파일러의 종류마다 다를 수 있음


- 고급언어에서 저급언어로 변환될때 크게 2가지 방식이 있는데 컴파일 방식과 인터프리터 방식이 있음

## 컴파일 언어
- 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어
- 컴파일 언어로 작성된 소스 코드를 저급 언어로 변환하는 과정을 compile
- compile을 수행해 주는 도구를 compiler라고 함
- 소스 코드 내에 하나의 오류라도 발견된다면 compile에 실패 함
- compiler를 통해 저급 언어로 변환된 코드를 object code(목적 코드) 라고 함

## 인터프리터 언어
- 소스 코드를 한줄씩 차례로 실행
- 소스 코드를 한줄씩 저급 언어로 변환해주는 도구를 interprter라고 함
- 중간에 오류가 있어도 오류가 있기 전까지 수행함
- 소스 코드 전체를 저급 언어로 변환하는 시간이 필요 없음
- 인터프리터 언어는 컴파일 언어보다 느린데 한줄 한줄씩 저급 언어로 해석하며 실행해야 하기 때문

**컴파일 언어와 인터프리터 언어의 구분**
- C나 C++처럼 명확하게 구분하는 언어도 있지만 많은 언어들이 컴파일 방식과 인터프리터 방식이 모호한 경우가 많음
- 인터프리터 언어가 컴파일을 하지 않거나 불가능한것도 아니며 Java의 경우 컴파일과 인터프리트를 동시에 수행함

# 7강
![]({{site.url}}/images/commandField.png)
- 명령어는 연산 코드와 operand(피연산자) 구조로 되어 있음
- 색이 입혀진 필드 값, 명령어가 수행할 연산을 operation code, 또는 operation field 라고 함 
- 연산에 사용할 데이터, 또는 연산에 사용할 데이터가 저장된 위치를 operand, 또는 operand field라고 함

## operation code(연산 코드)
- 연산 코드의 종류가 많지만 기본적으로 4가지가 있음
    - 데이터 전송
    - 산술/논리 연산
    - 제어 흐름 변경
    - 입출력 제어

## operand field (address field)
- 숫자나 문자 같은 데이터나 메모리, 레지스터 주소가 있음
- 하나도 없을 수 있고 한 개만 있을 수 있고 여러개가 있을 수 있음
    - 하나도 없는 경우 0-주소 명령어, 한 개만 있을 경우 1-주소 명령어, 2개가 있을 경우 2-주소 명령어
- 대부분의 경우 직접적으로 데이터를 명시하기 보다는 메모리 주소나 레지스터 이름이 담김

## addressing mode(주소 지정 방식)
![]({{site.url}}/images/addressingMode.png)
- 명령어 전체 크기에서 연산 코드 필드를 제외한 나머지로 operand로 사용하게 됨
- 나머지 중에서 2개 이상의 명령어가 있을 경우 또 나눠서 operand의 값을 넣을 수 있음
- 예를 들어 명령어의 전체 크기가 16비트, 연산 코드가 4비트일 때 2-주소 명령어는 필드당 6bit 
- 즉 하나의 operand field로 정보를 표현할 수 있는 가짓수는 32개 밖에 되지 않음
- 하지만 operand field 안에 정보가 아닌 메모리 주소가 담긴다면 표현할 수 있는 데이터 크기는 메모리 주소에 저장할 수 있는 공간만큼 커짐

### immediate addressing mode(즉시 주소 지정 방식)
![]({{site.url}}/images/immediateAddressingMode.png)
- 연산에 사용할 데이터를 operand field에 직접 명시함
- 가장 간단한 지정 방식이며 표현할 수 있는 데이터 크기가 작음
- 하지만 연산에 사용할 메모리나 레지스터로 부터 찾는 과정이 없기 때문에 빠름

### direct addressing mode(직접 주소 지정 방식)
![]({{site.url}}/images/directAddressingMode.png)
- operand field에 유효 주소를 직접적으로 명시하는 방법
- 즉시 주소 방식보다는 데이터 크기가 커졌지만 여전히 operand field 길이 만큼 유효 주소에 제한이 생길 수 있음

### indirect addressing mode(간접 주소 지정 방식)
![]({{site.url}}/images/indirectAddressingMode.png)
- 유효의 주소의 주소를 operand field에 명시
- 유효 주소의 범위가 넓어짐
- 하지만 두 번의 메모리 접근이 필요하기 때문에 느린 방식
- **CPU가 Memory에서 값을 찾는 시간은 상대적으로 오래 걸림, 때문에 메모리 접근을 최소화 하는것이 좋음** 

### register addressing mode(레지스터 주소 지정 방식)
![]({{site.url}}/images/registerAddressingMode.png)
- 직접 주소 지정 방식과 비슷함. 데이터를 저장한 레지스터를 operand field에 직접 명시
- CPU 외부에 있는 메모리에 접근하는것 보다 내부에 있는 레지스터에 접근하는것이 빠름 

### register indirect addressing mode(레지스터 간접 주소 지정 방식)
![]({{site.url}}/images/registerIndirectAddressingMode.png)
- 연산에 사용할 데이터를 메모리에 저장하고 메모리의 유효 주소를 레지스터에 저장한 다음 그 레지스터를 operand field에 명시
- 간접 주소 지정 방식과 비슷하지만 메모리의 접근 횟수가 한 번으로 줄어드는 장점이 있음

# 9강
## ALU
![]({{site.url}}/images/ALU.png)
- ALU는 레지스터를 통해 피연산자를 받고, 제어장치로부터 수행할 연산을 알려주는 제어 신호를 받음
- 연산을 수행한 결과 값은 데이터(숫자, 문자)나 메모리 주소가 될 수 있음
- 이 결과값은 바로 메모리에 저장되지 않고 일시적으로 레지스터에 저장됨 (메모리 접근속도 < 레지스터 접근 속도 때문)

## flag(플래그)
- 연산 결과에 추가적인 상태 정보
- flag들은 플래그 레지스터에 저장됨
|플래그 종류|의미|
|---|---|
|부호 플래그|연산한 결과의 부호를 나타냄|
|제로 플래그|연산 결과가 0인지 여부를 나타냄|
|캐리 플래그|연산 결과 올림수나 빌림수가 발생했는지 나타냄|
|오버플로우 플래그|overflow가 발생했는지 나타냄|
|인터럽트 플래그|인터럽트가 가능한지 나타냄|
|슈퍼바이저 플래그|커널 모드로 실행중인지 사용자 모드로 실행중인지 나타냄|

## 제어장치
- 제어 신호를 내보내고 명령어를 해석하는 부품
- 제어 신호는 컴퓨터 부품을 관리하고 작동시키는 전기 신호
- CPU 제조사마다 제어장치의 구현 방식이나 명령어를 해석하고 받아들이고 내보내는 방식에는 조금씩 차이가 있음

1. clock(클럭) 신호를 받아들임
- clock이란 컴퓨터의 부품을 움직일 수 있게 하는 시간 단위
- clock 주기에 맞춰서 레지스터에서 다른 레지스터로 데이터가 이동하거나, ALU에서 연산이 수행되거나, CPU가 메모리에 저장된 명령어를 읽어들임

2. 해석해야 할 명령어를 받아들임
- CPU가 해석할 명령어는 명령어 레지스터에 저장되는데 이 레지스터로 부터 명령어를 받아들이고 해석한 뒤 제어 신호를 발생시킴

3. 플래그 레지스터 속 플래그 값을 받아들임
- ALU의 추가적인 상태정보인 flag값을 받아들이고 이를 참고하여 제어 신호를 발생

4. 시스템 버스 그 중에서 제어 버스로 전달된 제어 신호를 받아들임
- 제어 신호는 CPU뿐만 아니라 입출력장치나 CPU 외부 장치에서도 발생할 수 있음
- 그래서 제어 장치는 제어 버스를 이용해 외부로부터 전달된 제어 신호를 받아 들임

# 10강
## 레지스터
- ALU와 제어장치는 프로그래머가 직접 관리할 일은 적음
- 레지스터를 관찰하는 일은 생각보다 많음(low-level 개발자 한정)
- 레지스터의 종류나 갯수는 심지어 똑같은 용도의 레지스터도 CPU마다 다름
- 그럼에도 대부분의 CPU에서 공통적으로 사용하는 8가지의 레지스터가 있음

1. Program Counter(프로그램 카운터)
- 메모리에서 가져올 명령어의 주소

2. Instruction Register(명령어 레지스터)
- 방금 메모리에서 읽은 명령어를 저장하는 레지스터, 제어장치는 명령어 레지스터의 명령어를 받고 해석한 뒤 제어 신호를 내보냄

3. Memory Address Register(메모리 주소 레지스터)
- 메모리의 주소를 저장하는 레지스터, CPU가 읽고자 하는 주소 값을 주소 버스로 보낼 때 거치게 됨

4. Memory Buffer Register(메모리 버퍼 레지스터)
- 메모리에 쓰이는 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거침
- 데이터 버스로 주고받을 값은 메모리 버퍼 레지스터를 거치게 됨

5. General Purpose Register(범용 레지스터)
- 메모리 버퍼 레지스터는 데이터 버스로 주고받을 값만 저장하고,
- 메모리 주소 레지스터는 주소 버스로 내보낼 값만 저장하지만
- 범용 레지스터는 모두 저장할 수 있으며 자유롭게 사용할 수 있는 레지스터

6. Flag Register(플래그 레지스터)
- 연산 결과, CPU 상태에 대한 부가적인 정보를 저장하는 레지스터


특별한 주소지정에서 사용
7. Stack Pointer(스택 포인터)
- **스택 주소 지정 방식**
- 스택 주소 지정 방식 사용
- 스택 포인터: 스택의 꼭대기를 가리키는 레지스터 (스택이 어디까지 차 있는지에 대한 표시)

- **변위 주소 지정 방식**
    
8. 베이스 레지스터

# 11강
## Instruction Cycle(명령어 사이클)
- 하나의 명령어를 처리하는 정형화된 흐름
- 프로그램 속 각각의 명령어들은 일정 주기가 반복되면서 실행
- memory에서 CPU로 가지고 오는 단계를 fetch cycle(인출 사이클)라고 함
- CPU로 명령어를 인출해서 가져온 명령어를 실행하는 단계를 execution cycle(실행 사이클)라고 함
- 실행사이클에서는 제어장치가 명령어 레지스터에 담긴 값을 해석하고 제어 신호를 발생 시키는 단계
- 하지만 모든 명령어가 인출해서 CPU로 가져왔다고 해도 바로바로 실행할 수 있는게 아님
- ex) 간접 주소 지정 방식은 operand field에 유효 주소의 주소를 명시하기 때문에 CPU로 가져왔다고 해도 memory로 접근을 한 번 더 해야함
- 이 단계를 indirect cycle(간접 사이클)라고 함

## Interrupt(인터럽트)
- CPU는 정해진 흐름에 따라 명령어를 처리하지만 이 흐름이 끊어지는 상황이 발생
- CPU의 정상적인 작업을 방해하는 신호

### synchronous interrupts(동기 인터럽트) / exception(예외)
- CPU에 의해 발생하는 인터럽트
- CPU가 명령어들을 수행하다가 예상치 못한 상황이 발생할 때, ex) 프로그래밍상의 오류

### asynchronous interrupts(비동기 인터럽트)
- 주로 입출력장치에 의해 발생하는 인터럽트, 알림과 같은 인터럽트
- ex) CPU가 프린터에 작업을 부탁했다면 프린터는 작업을 끝낸 뒤에 CPU에 완료 알림(인터럽트)을 보냄
- ex) 키보드, 마우스가 입력을 했을 때 이를 처리하기 위해 CPU에 입력 알림(인터럽트)을 보냄
- 입출력장치는 CPU보다 작업처리 속도가 현저하게 느림
- 그래서 CPU는 입출력장치에 대한 결과물을 바로 받아볼 수 없음
- 그래서 주기적으로 완료 여부를 확인해야 하는데 이는 CPU의 사이클 낭비가 됨
- 하지만 비동기 인터럽트를 사용하면 완료여부를 확인할 필요 없이 다른 작업을 처리할 수 있음

**비동기 인터럽트 처리 순서(하드웨어에 의한)**
1. 입출력장치는 CPU에 **인터럽트 요청 신호**를 보냄
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부 확인
3. CPU는 인터럽트 요청 확인, **인터럽트 플래그**를 통해 지금 인터럽트를 받아들일 수 있는지 여부 확인
4. 받아들일 수 있다면 CPU는 지금까지의 작업을 백업
5. CPU는 **인터럽트 벡터**를 참조해서 **인터럽트 서비스** 루틴 실행
6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해 둔 작업을 복구해서 실행 재개

### Interrupt Request(인터럽트 요청 신호)
- 인터럽트는 CPU의 정상적인 흐름을 끊는거기 때문에 신호를 먼저 보내서 여부를 확인해야함
- 그래서 인터럽트를 보내는 장치들이(입출력장치) CPU에 요청 신호를 보냄  

### Interrupt Flag(인터럽트 플래그)
- 인터럽트 요청 신호를 받아들일지 무시할지를 결정하는 bit
- CPU가 인터럽트 요청을 수용하기 위해 플래그 레지스터의 인터럽트 플래그가 활성화되어야 함
    - Maskable Interrupt(막을 수 있는 인터럽트)
    - Non Maskable Interrupt(막을 수 없는 인터럽트)
    ex) 가장 우선순쉬가 높은(가장 먼저 처리해야 하는) 인터럽트

### Interrupt Service Routine(인터럽트 서비스 루틴) / Interrpt Handler(인터럽트 핸들러)
- 인터럽트를 처리하기 위한 프로그램
- 키보드,마우스 등 어떤 종류에 인터럽트가 발생했을 때 그에 따른 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어짐
- 인터럽트를 처리하는 방법은 입출력장치마다 다름, 각기 다른 인터럽트 서비스 루틴을 가지고 있음

### Interrupt Vector(인터럽트 벡터)
- 인터럽트는 입출력장치마다 종류가 다르기 때문에 구분하기 위해 인터럽트 벡터 사용
- 인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작 주소를 알 수 있기 때문
- 인터럽트 서비스 루틴의 시작주소를 통한 인터럽트 서비스 루틴을 식별 정보

CPU가 인터럽트를 처리한다
- 인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다 와 같음

## Reference
[혼자 공부하는 컴퓨터구조]()
