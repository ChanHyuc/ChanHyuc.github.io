---
title: "Computer Architecture"
categories: Computer Architecture
---
# 1강
## Computer Architecture(컴퓨터 구조)
- 컴퓨터의 구성요소나 작동원리를 몰라도 프로그래밍 문법만 알면 개발을 하는데 전혀 지장이 없음
- 때문에 '개발자면 코드만 잘 설계하면 되는거 아닌가?' 라는 의문을 가질 수 있음
- 하지만 좋은 개발자가 되려면 프로그래밍 언어의 문법과 함께 **컴퓨터의 근간**(컴퓨터구조, 운영체제)을 알아야 함
- 문제 해결 능력을 기를 수 있음
    - 똑같은 코드를 작성했지만 실행하는 컴퓨터에 따라서 실행이 되거나 에러가 생길 수 있음 (빈번함)
    - 내가 작성한 코드가 내 컴퓨터에서는 작동이 되었지만 배포후에 다른 사람 컴퓨터에서는 작동이 안될 수도 있음
    - 컴퓨터 구조를 이해하면 문제 상황을 빠르게 진단하고 다양한 문제 해결방법을 찾을 수 있음
- 성능, 용량, 비용을 고려한 개발을 할 수 있음
    - 내가 지금 개발한 코드가 얼만큼의 성능을 가진 컴퓨터를 필요로 하는지를 개발자 스스로 판단할 수 있어야함
    - 클라우드 서비스를 이용하더라도 CPU, 메모리, 저장용량등은 직접 선택해야함

# 2강

## 컴퓨터가 이해하는 정보
### 데이터
- 숫자, 문자, 이미지, 동영상과 같은 정적인 정보
- 컴퓨터 내부에 저장된 정보를 데이터라고도 함
- 데이터는 명령어 없이는 아무것도 할 수 없는 정보 덩어리일 뿐

### 명령어
- 데이터를 움직이고 컴퓨터를 실질적으로 작동시킴.
ex) 4와 11을 더하라  // 4와 11은 데이터, 더하라는 명령어

## 컴퓨터의 네 가지 핵심 부품
- 라즈베리파이, 아두이노, 스마트폰, 노트북, 서버컴퓨터 등 다양한 종류의 컴퓨터가 있음
- 하지만 핵심 부품인 4가지는 공통적으로 가지고 있음
- 컴퓨터 부품끼리 서로 정보를 주고 받기 위한 통로를 Bus
- 다양한 Bus들이 있지만 컴퓨터의 네 가지 핵심부품끼리 정보를 주고받는 가장 중요한 Bus를 시스템 Bus

### 메인보드
- 메인보드에 연결된 부품은 버스를 통해 정보를 주고 받음
- 컴퓨터의 네 가지 핵심 부품을 연결하는 버스가 System Bus(시스템 버스)

### 시스템 버스
- 주소 버스: 주소를 주고받음
- 데이터 버스: 데이터와 명령어를 주고받음
- 제어 버스: 제어 신호를 주고받음

1. CPU (Central Processing Unit)
- 메모리에 저장된 명령어를 읽고 해석하고 실행함
- ALU(Arithmetic and Logical Unit, 산술연산장치): 계산만 함, 컴퓨터의 대부분 계산을 함
- Control Unit(제어장치): 제어 신호(메모리 읽기 / 메모리 쓰기)를 주거나 받고, 명령어를 해석
- Register: CPU 안의 작은 저장장치, CPU안에 여러 레지스터가 있고 각자 다른 이름과 역할이 있음

2. Main Memory(주 기억장치)
- 프로그램(데이터, 명령어)이 실행되기 위해서는 메모리에 저장되어 있어야함
- 메모리는 Process(현재 실행되는 프로그램)의 명령어와 데이터를 저장함
- 메모리에 저장된 값의 위치는 주소로 알 수 있음 

3. Secondary Storage (보조기억장치)
- Memory(주 기억 장치)는 가격이 비싸고 전원이 꺼지면 저장된 내용이 사라짐(휘발성)
- 보조기억장치는 전원이 꺼져도 프로그램(데이터, 명령어)을 저장함(비휘발성)

4. input/ouput (I/O)Device(입출력장치)
- 컴퓨터 외부와 내부를 연결하여 정보를 교환함

# 4강
## bit 및 단위
- 0과 1을 나타내는 가장 작은 정보의 단위인 bit
- n 비트로 2ⁿ가지의 정보 표현 가능
- 프로그램은 수많은 bit로 이루어져 있음

|단위|전 단위|
|---|---|
|1btye|8bit|
|1kB|1,000byte|
|1MB|1,000kB|
|1GM|1,000MB|
|1TB|1,000GM|

### word(워드)
- CPU가 한 번에 처리할 수 있는 데이터 크기를 말함
- 워드의 절반 크기를 half word, 1배 크기를 full word, 2배 크기를 double word 라고 함
- CPU마다 처리할 수 있는 양이 다르지만 대부분 워드 크기는 32비트와 64비트 

## Binary(이진법)
- 0과 1만으로 숫자를 표현함
- 십진수와 숫자가 똑같을 경우가 많아 혼동을 예방하기 위해
    - 아래첨자 ₂를 붙이거나 ex) 1000(₂), 주로 수학적으로 표기할 때
    - 이진수 앞에 0b를 붙임 ex) 0b1000, 주로 코드상에서 표기할 때

### 이진수의 음수
- 십진수처럼 부호를 붙이는게 아닌 0과 1만 이해할 수 있으므로 다른 방식으로 음수를 표현 해야 함

**ex) 1101(₂)의 음수를 구할 때**
- 0100 : 모든 0과 1을 뒤집음 (1의 보수)
- 0101 : 뒤집은 수에서 1을 더함 (2의 보수)
- 1101(₂)의 음수는 0101이 나왔는데 이것을 증명하기 위해서 0101(₂)을 음수를 구하면 1101(₂)가 나옴

**음수 양수 구별**
- 0101(₂)은 양수인지 음수인지 구별할 수 없음
- 그래서 flag를 사용함

**2의 보수 한계**
1. 0000을 음수로 표현하면 1111 -> 10000 이 나옴
2. 1000 2의 3제곱을 음수로 표현하면 0111 -> 1000 똑같이 나옴

## Hexadecimal(십육진법)
- 이진법은 숫자의 길이가 너무 길어진다는 단점이 있음
- 16진법은 15에서 16을 넘어가는 시점에서 자리올림을 함
- A: 10, B: 11, C: 12, D: 13, E: 14, F: 15로 표기
    - 아래첨자 16을 붙이거나 ex) 11(₁₆)
    - 16진수 앞에 0x를 붙여 구분 ex) 0x11

**16진수를 사용하는 이유**
이진수와 십진수를 서로 변환하는것보다
이진수와 십육진수를 서로 변환하는것이 쉽기 때문

### 16진수 -> 2진수 변환
- 16진수 하나를 2진수로 표현하려면 4개의 bit가 필요함 2⁴ = 16 때문
- 16진수 하나하나를 각자 2진수로 바꾼다음에 그대로 이어붙이면 됨

ex) 1A2B(₁₆)
1 -> 0001, A -> 1010, 2 -> 0010, B -> 1011
0001101000101011(₂)

### 2진수 -> 16진수 변환
- 반대의 경우도 마찬가지로 2진수를 4개씩 끊고 16진수로 바꾼다음 그대로 이어붙이면 됨

ex) 10101101(₂)
1010 -> A, 1101 -> D
AD(₁₆)

# 5강
1. character set(문자 집합)
- 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
2. character Encoding(문자 인코딩)
- 문자 집합에 있는 문자를 Encoding 과정을 거쳐 컴퓨터가 이해할 수 있는 0과 1로 이루어진 문자 코드가 됨
3. character Decoding(문자 디코딩)
- 반대로 컴퓨터가 이해할 수 있는 0과 1로 이루어진 문자코드를 사람이 읽을 수 있는 문자로 변환하는 과정

## ASCII(아스키 코드)
- 초창기 문자 집합 중 하나로 영어, 숫자, 일부 특수문자 포함
- 하나의 아스키 문자를 위해 8bit(1byte)를 사용하는데 1bit는 Parity bit로 오류 검출을 위해 사용됨
- 때문에 실질적으로 7bit로 표현할 수 있고 7비트로 표현할 수 있는 정보의 가짓수는 128개

## EUC-KR
- 한글 전용 인코딩
- 완성형 인코딩으로 초성, 중성, 종성의 조합으로 이루어진 하나의 완성된 글자에 고유한 코드를 부여
- 한글 단어 하나에 2byte 크기의 코드 부여
- 2350개 정도의 한글을 표현할 수 있지만 부족함

## Unicode(유니코드)
- 대부부의 나라의 문자, 특수문자, 이모티콘 까지 코드로 표현할 수 있는 통일된 문자 집합
- 글자에 부여된 값 자체를 인코딩된 값으로 정하지 않고 이 값을 다양한 방법으로 인코딩 함
- 종류로는 UTF-8, UTF-16, UTF-32 등이 있음 각각 인코딩 하는 방식
- 가장 대중적으로 UTF-8을 사용함

# 6강
## high-level Programming language(고급언어)
- 사람이 이해하기 쉽게 만들어진 언어
- 대부분의 프로그래밍 언어

## low-level Programming language(저급언어)
- 컴퓨터가 직접 이해하고 실행할 수 있는 언어
- 기계어와 어셈블리어가 있음
- 하드웨어와 밀접하게 맞닿은 프로그램을 개발하는 임베디드 개발자, 게임 개발자, 정보보안 개발자 등에서 어셈블리어를 많이 사용
- 어셈블리어를 읽으면 컴퓨터가 프로그램을 어떤 과정으로 실행하는지 어떤 절차로 작동하는지 근본적인 단계부터 추적하고 관찰할 수 있음
- 어셈블리어는 CPU마다 컴파일러의 종류마다 다를 수 있음


- 고급언어에서 저급언어로 변환될때 크게 2가지 방식이 있는데 컴파일 방식과 인터프리터 방식이 있음

## 컴파일 언어
- 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어
- 컴파일 언어로 작성된 소스 코드를 저급 언어로 변환하는 과정을 compile
- compile을 수행해 주는 도구를 compiler라고 함
- 소스 코드 내에 하나의 오류라도 발견된다면 compile에 실패 함
- compiler를 통해 저급 언어로 변환된 코드를 object code(목적 코드) 라고 함

## 인터프리터 언어
- 소스 코드를 한줄씩 차례로 실행
- 소스 코드를 한줄씩 저급 언어로 변환해주는 도구를 interprter라고 함
- 중간에 오류가 있어도 오류가 있기 전까지 수행함
- 소스 코드 전체를 저급 언어로 변환하는 시간이 필요 없음
- 인터프리터 언어는 컴파일 언어보다 느린데 한줄 한줄씩 저급 언어로 해석하며 실행해야 하기 때문

**컴파일 언어와 인터프리터 언어의 구분**
- C나 C++처럼 명확하게 구분하는 언어도 있지만 많은 언어들이 컴파일 방식과 인터프리터 방식이 모호한 경우가 많음
- 인터프리터 언어가 컴파일을 하지 않거나 불가능한것도 아니며 Java의 경우 컴파일과 인터프리트를 동시에 수행함

# 7강
![]({{site.url}}/images/commandField.png)
- 명령어는 연산 코드와 operand(피연산자) 구조로 되어 있음
- 색이 입혀진 필드 값, 명령어가 수행할 연산을 operation code, 또는 operation field 라고 함 
- 연산에 사용할 데이터, 또는 연산에 사용할 데이터가 저장된 위치를 operand, 또는 operand field라고 함

## operation code(연산 코드)
- 연산 코드의 종류가 많지만 기본적으로 4가지가 있음
    - 데이터 전송
    - 산술/논리 연산
    - 제어 흐름 변경
    - 입출력 제어

## operand field (address field)
- 숫자나 문자 같은 데이터나 메모리, 레지스터 주소가 있음
- 하나도 없을 수 있고 한 개만 있을 수 있고 여러개가 있을 수 있음
    - 하나도 없는 경우 0-주소 명령어, 한 개만 있을 경우 1-주소 명령어, 2개가 있을 경우 2-주소 명령어
- 대부분의 경우 직접적으로 데이터를 명시하기 보다는 메모리 주소나 레지스터 이름이 담김

## addressing mode(주소 지정 방식)
![]({{site.url}}/images/addressingMode.png)
- 명령어 전체 크기에서 연산 코드 필드를 제외한 나머지로 operand로 사용하게 됨
- 나머지 중에서 2개 이상의 명령어가 있을 경우 또 나눠서 operand의 값을 넣을 수 있음
- 예를 들어 명령어의 전체 크기가 16비트, 연산 코드가 4비트일 때 2-주소 명령어는 필드당 6bit 
- 즉 하나의 operand field로 정보를 표현할 수 있는 가짓수는 32개 밖에 되지 않음
- 하지만 operand field 안에 정보가 아닌 메모리 주소가 담긴다면 표현할 수 있는 데이터 크기는 메모리 주소에 저장할 수 있는 공간만큼 커짐

### immediate addressing mode(즉시 주소 지정 방식)
- 연산에 사용할 데이터를 operand field에 직접 명시함
- 가장 간단한 지정 방식이며 표현할 수 있는 데이터 크기가 작음
- 하지만 연산에 사용할 메모리나 레지스터로 부터 찾는 과정이 없기 때문에 빠름

### direct addressing mode(직접 주소 지정 방식)
- operand field에 유효 주소를 직접적으로 명시하는 방법
- 즉시 주소 방식보다는 데이터 크기가 커졌지만 여전히 operand field 길이 만큼 유효 주소에 제한이 생길 수 있음

### indirect addressing mode(간접 주소 지정 방식)
- 유효의 주소의 주소를 operand field에 명시
- 유효 주소의 범위가 넓어짐
- 하지만 두 번의 메모리 접근이 필요하기 때문에 느린 방식
- **CPU가 Memory에서 값을 찾는 시간은 상대적으로 오래 걸림, 때문에 메모리 접근을 최소화 하는것이 좋음** 

### register addressing mode(레지스터 주소 지정 방식)
- 직접 주소 지정 방식과 비슷함. 데이터를 저장한 레지스터를 operand field에 직접 명시
- CPU 외부에 있는 메모리에 접근하는것 보다 내부에 있는 레지스터에 접근하는것이 빠름 

### register indirect addressing mode(레지스터 간접 주소 지정 방식)
- 연산에 사용할 데이터를 메모리에 저장하고 메모리의 유효 주소를 레지스터에 저장한 다음 그 레지스터를 operand field에 명시
- 간접 주소 지정 방식과 비슷하지만 메모리의 접근 횟수가 한 번으로 줄어드는 장점이 있음

# 9강
## ALU
- ALU는 레지스터를 통해 피연산자를 받고, 제어장치로부터 수행할 연산을 알려주는 제어 신호를 받음
- 연산을 수행한 결과 값은 데이터(숫자, 문자)나 메모리 주소가 될 수 있음
- 이 결과값은 바로 메모리에 저장되지 않고 일시적으로 레지스터에 저장됨 (메모리 접근속도 < 레지스터 접근 속도 때문)

## flag(플래그)
- 연산 결과에 추가적인 상태 정보
- flag들은 플래그 레지스터에 저장됨
|플래그 종류|의미|
|---|---|
|부호 플래그|연산한 결과의 부호를 나타냄|
|제로 플래그|연산 결과가 0인지 여부를 나타냄|
|캐리 플래그|연산 결과 올림수나 빌림수가 발생했는지 나타냄|
|오버플로우 플래그|overflow가 발생했는지 나타냄|
|인터럽트 플래그|인터럽트가 가능한지 나타냄|
|슈퍼바이저 플래그|커널 모드로 실행중인지 사용자 모드로 실행중인지 나타냄|

## 제어장치
- 제어 신호를 내보내고 명령어를 해석하는 부품
- 제어 신호는 컴퓨터 부품을 관리하고 작동시키는 전기 신호
- CPU 제조사마다 제어장치의 구현 방식이나 명령어를 해석하고 받아들이고 내보내는 방식에는 조금씩 차이가 있음

1. clock(클럭) 신호를 받아들임
- clock이란 컴퓨터의 부품을 움직일 수 있게 하는 시간 단위
- clock 주기에 맞춰서 레지스터에서 다른 레지스터로 데이터가 이동하거나, ALU에서 연산이 수행되거나, CPU가 메모리에 저장된 명령어를 읽어들임

2. 해석해야 할 명령어를 받아들임
- CPU가 해석할 명령어는 명령어 레지스터에 저장되는데 이 레지스터로 부터 명령어를 받아들이고 해석한 뒤 제어 신호를 발생시킴

3. 플래그 레지스터 속 플래그 값을 받아들임
- ALU의 추가적인 상태정보인 flag값을 받아들이고 이를 참고하여 제어 신호를 발생

4. 시스템 버스 그 중에서 제어 버스로 전달된 제어 신호를 받아들임
- 제어 신호는 CPU뿐만 아니라 입출력장치나 CPU 외부 장치에서도 발생할 수 있음
- 그래서 제어 장치는 제어 버스를 이용해 외부로부터 전달된 제어 신호를 받아 들임

## Reference
[혼자 공부하는 컴퓨터구조]()
