---
title: "메모리와 캐시 메모리"
categories: ComputerArchitecture
---
## RAM
- 실행할 프로그램의 명령어와 데이터를 저장하는 부품
- Volatile Memory(휘발성 저장 장치): 전원을 끄면 저장된 내용이 사라지는 특성
- CPU는 보조기억장치에 직접 접근하지 못함
- CPU가 실행하고 싶은 프로그램이 보조기억장치에 있다면 RAM으로 복사하여 저장한 뒤 실행
- 즉, RAM은 **실행할 대상**, 보조기억장치는 **보관할 대상**을 저장함

### RAM의 용량과 성능
- RAM의 용량이 작다면 보조기억장치에서 실행할 프로그램을 가져오는 일이 빈번해져 실행 시간이 길어짐
- 반대로 용량이 크다면 여러개의 프로그램들을 기억할 수 있기 때문에 빠르게 실행 시간이 빨라짐
- RAM의 용량이 커지면 실행 속도가 증가하지만 필요 이상으로 켜졌을 때는 유의미한 속도 변화 없음

### RAM의 종류

||DRAM|SRAM|
|---|---|---|
|재충전|필요함|필요 없음|
|속도|느림|빠름|
|가격|저렴함|비쌈|
|집적도|높음|낮음|
|소비전력|적음|높음|
|사용 용도|RAM(주기억장치)|캐시 메모리|

1. DRAM(Dynamic RAM)
- 데이터의 소멸을 막기 위해 일정 주기로 데이터를 저장 해야함
2. SRAM(Static RAM)
- 시간이 지나도 저장된 데이터가 사라지지 않음
- 빠르지만 비싸고, 소비전력이 크며, 집적도가 낮기 때문에 **대용량까지는 필요없지만 속도가 빨라야 하는 저장 장치**인 캐시 메모리에 사용
3. SDRAM(Synchronous Dynamic RAM)
- 클럭 신호와 동기화된 발전된 DRAM
- 클럭 타이밍에 맞춰 CPU와 정보를 주고받을 수 있음
4. DDR SDRAM(Double Data Rate SDRAM)
- 최근 가장 흔히 사용되는 RAM, **대역폭**을 넓혀 속도를 빠르게 만든 SDRAM
- Data Rate(대역폭): 데이터를 주고받는 길의 너비
- SDR(Single Data Rate)SDRAM에 비해 대역폭이 두 배 넓음

## 메모리의 주소 공간
- 메모리에서는 시시각각 프로그램이 적재되고 실행이 끝나면 삭제되며 같은 프로그램을 실행하더라도 실행할 때마다 **적재되는 주소가 달라질 수 있음**
- ex) A라는 프로그램을 실행했을 때 1000번지 적재 종료 후 다시 실행했을 때 2500번지에 적재
- 그래서 CPU는 실행중인 프로그램이 현재 메모리 몇 번지에 무엇이 저장되어 있는지 다 알지 못함

### Physical Address(물리 주소)
- 메모리가 사용하는 주소(하드웨어상의 실제 주소)
- 실제 주소기 때문에 0번지는 하나밖에 없음

### Logical Address(논리 주소)
- 실행 중인 프로그램 각각에 부여된 주소, CPU가 이해하는 주소
- 모든 실행중인 프로그램마다 논리주소 0번지부터 시작함
- 즉, 프로그램을 여러개 실행한다면 논리 주소는 **얼마든지 겹칠 수 있음**

### MMU(Memory Management Unit, MMU)
- CPU와 주소 버스 사이에 위치한 하드웨어 장치, 주소 간의 변환 작업을 함
- 메모리는 **물리 주소**를 사용하고 CPU는 **논리 주소**를 사용하기 때문에 **주소 간의 변환**이 이루어져야 상호작용을 할 수 있음
- CPU가 발생시킨 논리 주소에 베이스 레지스터 값을 더해서 논리 주소 -> 물리 주소로 변환

**예시**

![]({{site.url}}/images/ComputerArchitecture/MMU.png)
- 베이스 레지스터에 1000이 저장되어 있고, CPU가 발생 시킨 논리 주소가 100번지라면 1100번지(1000 + 100)로 변환
- 물리 주소 1000번지부터 적재된 프로그램 A의 논리 주소 100번지에 접근하는 것
- 베이스 레지스터는 프로그램의 가장 작은 물리 주소를 저장(첫 물리 주소)
- 논리 주소는 프로그램의 시작점으로부터 떨어진 거리

### 메모리 보호 기법
- Limit Register(한계 레지스터)
    - 논리 주소 범위를 벗어나는 명령어 실행을 방지
    - 실행 중인 프로그램이 다른 프로그램에 영향을 받지 않도록 보호하는 역할
    - 논리 주소의 최대 크기를 저장
- 즉 프로그램의 물리 주소 범위는 **베이스 레지스터 값**이상 ~ **베이스 레지스터 값 + 한계 레지스터 값** 미만

![]({{site.url}}/images/ComputerArchitecture/LimitRegister1.png)

**예시**

![]({{site.url}}/images/ComputerArchitecture/LimitRegister2.png)
- 베이스 레지스터가 100, 한계 레지스터가 100이 저장된 프로그램 A가 있음
- 물리 주소 시작점이 100이고 프로그램 크기(논리 주소의 최대 크기)는 100임을 의미함
- A프로그램은 100번지를 넘는 논리 주소는 가질 수 없음
- 그림 처럼 100번지를 넘는 논리 주소를 가질 경우 다른 프로그램을 침범해서 예기치 못한 결과를 발생

**메모리 보호 기법 순서도**
![]({{site.url}}/images/ComputerArchitecture/LimitRegister3.png) 


## Memory Hierarchy(저장 장치 계층 구조)
- 컴퓨터가 사용하는 저장 장치들을 **CPU에 얼마나 가까운가**를 기준으로 계층적으로 나타냄

![]({{site.url}}/images/ComputerArchitecture/MemoryHierarchy.png)

### Cache Memory(캐시 메모리)
- CPU 연산속도가 아무리 빨라도 메모리에 접근하는 시간이 느리면 연산속도는 아무 쓸모가 없어짐
- CPU의 연산 속도와 CPU의 메모리 접근 속도의 차이를 줄이기 위해 사용
- CPU와 메모리 사이에 위치하고 레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반의 저장 장치
- 메모리에서 CPU가 사용할 일부 데이터를 미리 캐시 메모리로 가지고 와서 활용
- 캐시 메모리들은 CPU와 가까운 순서대로 계층을 구성함(코어와 가장 가까운 캐시 메모리를 L1, 그 다음 L2, 그 다음 L3)
- 일반적으로 L1캐시, L2 캐시는 코어 내부에, L3 캐시는 코어 외부에 있음

### Split Cache(분리형 캐시) 
- 코어에 가장 가까운 L1 캐시는 조금이라도 접근 속도를 빠르게 만들기 위해 명령어만을 저장하는 L1 캐시인 L1I(Instruction)캐시와 데이터만을 저장하는 L1 캐시인 L1D(Data) 캐시로 분리하는 경우가 많음

## Locality of Reference, Principle of Locality (참조 지역성 원리)
- 보조기억장치는 전원이 껴저도 기억할 대상을 저장, 메모리는 실행 중인 프로그램을 저장
- 캐시 메모리는 CPU가 사용할만한 대상을 예측하여 저장
- **Cache Hit**: 예측한 데이터가 실제로 맞아서 캐시 메모리 안의 데이터가 CPU에서 활용된 경우
- **Chche Miss**: 반대로 예측에 틀려서 메모리에서 필요한 데이터를 직접 가져와야 하는 경우
- Chche Miss가 발생하면 캐시 메모리의 장점을 활용할 수 없음
- Cache Hit Ratio: 캐시가 히트되는 비율
- 캐시 히트 횟수 / 메모리에 접근하는 횟수(캐시 히트 횟수 + 캐시 미스 횟수)

### Temporal Locality(시간 지역성)
- 최근에 접근했던 메모리 공간에 다시 접근하려는 경향
```cpp
#include<iostream>
int main() {
    int number = 2; 
    for(int i = 1; i <= 9; i++) 
        std::cout << number * i << '\n';
        // number 변수(주소 공간)에 다시 접근하는 경향이 보임
}
```

### Spatial Locality(공간 지역성)
- CPU가 실행하려는 프로그램은 보통 관련 데이터들끼리 모여 있음
    - ex) 게임은 게임관련 데이터끼리 저장되어 모여 있고, 메모장은 메모장 관련 데이터끼리 저장되어 모여 있고...
- 또한 하나의 프로그램에도 관련 있는 데이터들은 모여서 저장됨
    - ex) 메모장에 입력기능, 출력기능, 자동 저장 기능 등 각각 기능과 관련해서 모여서 저장
- 그래서 CPU는 메모장 프로그램을 실행할 때 메모장 프로그램이 모여 있는 공간 근처를 집중적으로 접근함
- 또한 메모장에서 입력할 때에는 메모장에서 입력 기능이 모여 있는 공간 근처를 집중적으로 접근함

## Reference
[혼자 공부하는 컴퓨터구조]()
