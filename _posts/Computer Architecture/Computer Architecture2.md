---
title: "Computer Architecture"
categories: ComputerArchitecture
---
# 빠른 CPU를 위한 설계 기법
## Clock(클럭)
- 클럭 신호가 빠르게 반복되면 CPU와 그 외의 부품들은 꼭 그런건 아니지만 일반적으로 빠른 박자로 움직임
- 즉 클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복함
- 클럭 속도가 높은 CPU는 일반적으로 성능이 좋고 그래서 클럭 속도는 CPU 속도 단위로 간주됨
- 클럭 속도는 헤르츠(Hz) 단위로 측정, 1초에 클럭이 몇 번 반복되는지 나타냄
- 클럭 속도는 고성능을 요구할 때 클럭 속도를 높이고 그렇지 않을 때는 낮추기도 함
- 최대 클럭 속도를 강제로 끌어올릴 수 있는 데 이런 기법을 **overcloking**이라고 함
- 고성능 작업을 장시간 할 경우 발열 문제가 심각해짐

## Core
- CPU에서 명령어를 실행하는 부품
- 클럭 속도를 높여서 CPU 성능을 올리는 방법에는 한계가 있음
- CPU의 Core나 Thread를 늘리는 방법이 있음
- ex) 8코어: 명령어를 실행하는 부품인 Core가 8개 있는 것
- Core가 하나만 있는것은 SingleCore, 여러개가 있는것을 MultiCore
- Core가 아무리 많아도 적절하게 명령어가 분배되지 않는다면 연산 속도가 증가 하지 않음
- 또한 작업량에 비해 Core수가 지나치게 많아도 유의미한 성능 변화가 없음 

## Thread
- 사전적인 의미로 '실행 흐름의 단위'

### 하드웨어적 스레드 / Logical Processor(논리 프로세서)
- 논리 프로세서: 실제 프로세서의 갯수는 아니지만 메모리가 실행되고 있는 프로그램이 몇개 인가 하드웨어 스레드 개수만큼 있음
- CPU에서 사용
- 1코어 1스레드 CPU도 여러개의 소프트웨어적 스레드를 만들 수 있음
- 1코어 1스레드는 실제로 동시에 작업하는게 아닌 매우 빠른속도로 번갈아 가면서 실행하기 때문
- 하나의 코어가 동시에 처리하는 명령어 단위
- 하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 MultiThread라고 함
- Hyper-Threading: Intel사의 MultiThread 기술
- 가장 큰 핵심은 레지스터
- 하나의 코어로 여러 명령어를 동시에 처리할 경우 하나의 명령어를 처리하기 위해 꼭 필요한 레지스터를 여러개를 가지면 됨
    - 프로그램 카운터
    - 스택 포인터
    - 데이터 버퍼 레지스터
    - 데이터 주소 레지스터
    
    
### 소프트웨어적 스레드
- 프로그램에서 사용
- 하나의 프로그램에서 독립적으로 실행되는 단위
- 하나의 프로그램에서 한개씩 실행할 수 있지만 여러 스레드를 사용할 경우 여러 부분을 동시에 실행할 수도 있음


# 명령어 병렬 처리 기법
- 빠른 CPU를 만들기 위해 높은 클럭속도, 코어와 스레드의 숫자도 중요하지만 CPU가 놀지 않고 효율적으로 작동하게 만드는것도 중요
- ILP(Instruction-Level Parallelism, 명령어 병렬 처리 기법)

## Instruction Pipelining(명령어 파이프라이닝)
- 명령어 처리 과정을 클럭 단위로 나누면 (이 단계가 명확하게 정답은 아님, 전공서마다 단계를 나누는게 다르기도 함)
1. Instruction Fetch(명령어 인출)
2. Instruction Decode(명령어 해석)
3. Execute Instruction(명령어 실행)
4. Write Back(결과 저장)
- 동시에 여러 개의 명령어를 겹처 실행하는 기법
- 중요한 것은 단계만 겹치지 않는다면 **각 단계를 동시에 실행할 수 있음**
- ex) A라는 명령어가 인출을 하고 있을 때 B명령어는 해석을 할 수 있고 C명령어는 실행할 수 있음
- 마치 공장 생산 라인과 같음
- 높은 성능을 가져오지만 특정 상황에서 성능 향상에 실패하는 경우도 있음(Pipeline Hazard, 파이프라인 위험)

1. Data Hazard(데이터 위험)
- 명령어 간 '데이터 의존성'에 의해 발생
- ex) 명령어1: R1 <- R2 + R3 // R2 레지스터 값과 R3 레지스터 값을 더한 값을 R1에 저장
- ex) 명령어2: R4 <- R1 + R5 // R1 레저스터 값과 R5 레지스터 값을 더한 값을 R4에 저장
명령어 1을 실행하고 결과값이 저장되고 나서 명령어 2를 실행해야 함
명령어 1의 결과값이 인출되기 전에 명령어 2를 실행할 경우 예기치 못한 결과값이 나올 수 있음
이런 상황을 명령어 2는 명령어 1의 데이터에 의존한다고 함
이처럼 의존적인 두 명령어를 무작정 동시에 실행할 경우 제대로 작동하지 않을 수 있음

2. Control Hazard(제어 위험)
- 분기 등으로 **프로그램 카운터의 예기치못한 변화**에 의해 발생
- 일반적으로 프로그램 카운터는 **현재 실행중인 명령어의 다음 주소**로 갱신됨
- 하지만 분기에 의해 실행 흐름이 바뀌어 변화가 생긴다면 파이프라인에 미리 가지고 와서 처리중이던 명령어들이 쓸모 없어질 수 있음
- 이를 위해 사용하는 기술이 breanch prediction(분기 예측), 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술 

3. Structural Hazard(구조적 위험) / Resource Hazard(자원 위험)
- 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같이 CPU를 사용하려 할 때

## SuperScalar(슈퍼스칼라)
- 오늘날 대부분의 CPU는 여러개의 파이프라인을 사용
- 이론적으로는 파이프라인 개수에 비례해서 프로그램 처리 속도가 빨라져야 되지만, 파이프라인 위험 때문에 개수에 비례해서 빨라지지 않음
- 이 때문에 슈퍼스칼라는 파이프라인 위험을 방지하기 위해 고도로 설계되어야 함

## Out-Of-Order Execution(비순차적 명령어 처리)
- 명령어들을 비순차적으로 실행하는 기법
- 파이프라인, 슈퍼스칼라는 프로그램을 위에서 아래로 차례대로 실행하는 방식
- 명령어를 순차적으로 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 파이프라인이 멈추는것을 방지함

# 명령어 집합 구조, CISC와 RISC
- CPU가 이해할 수 있는 명령어들의 모음을 Instruction Set(명령어 집합)또는 ISA(명령어 집합 구조)라고 함
- CPU마다 ISA가 다를 수 있음, ISA가 다르면 명령어가 다르기 때문에 서로의 명령어를 읽을 수 없음
- ISA가 다르면 어셈블리어도 달라짐, 똑같은 CPU여도 다른 컴파일러를 사용하면 어셈블리어가 달라짐
- ex) Intel CPU 컴퓨터에서 만든 실행파일을 아무 설정없이 그대로 ARM이 탑재된 아이폰에 가져올 경우 실행이 안됨

## CISC(Complex Instruction Set Computer)
- 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 가변 길이 명령어를 사용
- 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있음, 메모리 공간을 절약할 수 있음
- 단점으로 활용하는 명령어가 복잡하기 때문에 명령어의 크기와 실행되기까지의 시간이 일정치 않음
- 또한 명령어 하나를 실행하는 데에 여러 클럭 주기가 필요함
- 명령어가 일정하지 않기 때문에 명령어 파이프라인에서 효율적으로 동작하기 힘듦
- 다양한 명령어를 지원하지만 대다수의 명령어는 사용 빈도가 낮음 (사용하는것만 사용함)

## RISC(Reduced Instruction Set Computer)
- 명령어의 종류가 적고 CISC와 달리 짧고 규격화 됨(고정 길이 명령어)
- 하나의 명령어가 1클럭 내외로 실행되기 때문에 RISC는 명령어 파이프라이닝에 최적화 됨
- 메모리 접근을 단순, 최소화(load, store) 하는 대신 레지스터를 적극적으로 활용

|CISC|RISC|
|---|---|
|복잡하고 다양한 명령어|단순하고 적은 명령어|
|가변 길이 명령어|고정 길이 명령어|
|다양한 주소 지정|적은 주소 지정|
|프로그램을 이루는 명령어의 수가 적음|프로그램을 이루는 명령어의 수가 많음|
|여러 클럭을 거쳐서 수행|1클럭 내외로 수행|
|파이프라이닝하기 어려움|파이프라이닝에 최적화|

# RAM의 특성과 종류

## RAM의 특징
- 실행할 프로그램의 명령어와 데이터를 저장
- Volatile Memory(휘발성 저장 장치): 전원을 끄면 저장된 내용이 사라지는 특성

## RAM의 용량과 성능
- RAM의 용량이 작다면 보조기억장치에서 실행할 프로그램을 가져오는 일이 빈번해져 실행 시간이 길어짐
- 반대로 용량이 크다면 여러개의 프로그램들을 기억할 수 있기 때문에 빠르게 실행 시간이 빨라짐
- RAM의 용량이 커지면 실행 속도가 증가하지만 필요 이상으로 켜졌을 때는 유의미한 속도 변화 없음

## RAM의 종류
### DRAM(Dynamic RAM)
- 데이터의 소멸을 막기 위해 일정 주기로 데이터를 저장 해야함

### SRAM(Static RAM)
- 시간이 지나도 저장된 데이터가 사라지지 않음
- 빠르지만 비싸기 때문에 **대용량까지는 필요없지만 속도가 빨라야 하는 저장 장치**인 캐시 메모리에 사용 

|||DRAM|SRAM|
|---|---|---|
|재충전|필요함|필요 없음|
|속도|느림|빠름|
|가격|저렴함|비쌈|
|집적도|높음|낮음|
|소비전력|적음|높음|
|사용 용도|RAM(주기억장치|캐시 메모리|

### SDRAM(Synchronous Dynamic RAM)
- 클럭 신호와 동기화된 발전된 DRAM
- 즉 클럭 타이밍에 맞춰 CPU와 정보를 주고받을 수 있음

### DDR SDRAM(Double Data Rate SDRAM)
- 최근 가장 흔히 사용되는 RAM, 대역폭을 넓혀 속도를 빠르게 만든 SDRAM
- data rate(대역폭): 데이터를 주고받는 길의 너비
- SDR(Single Data Rate)SDRAM에 비해 대역폭이 두 배 넓음

# 메모리의 주소 공간, 물리 주소와 논리 주소

- 메모리에서는 시시각각 프로그램이 적재되고 실행이 끝나면 삭제되며 같은 프로그램을 실행하더라도 실행할 때마다 적재되는 주소가 달라질 수 있음
- ex) A라는 프로그램을 실행했을 때 1000번지 적재 종료 후 다시 실행했을 때 2500번지에 적재
- 메모리에 저장된 정보는 계속해서 변함 
- 그래서 CPU는 실행중인 프로그램이 현재 메모리 몇 번지에 무엇이 저장되어 있는지 다 알지 못함

## Physical Address(물리 주소)
- 정보가 저장된 하드웨어상의 주소
- 실제 주소기 때문에 0번지는 하나밖에 없음
- 메모리가 사용하는 주소(하드웨어상의 실제 주소)

## Logical Address(논리 주소)
- 모든 실행중인 프로그램마다 논리주소 0번지부터 시작함
- 실행 중인 프로그램 각각에 부여된 주소

메모리는 물리 주소를 사용하고 CPU는 논리 주소를 사용하기 때문에 주소 간의 변환이 이루어져야 상호작용을 할 수 있음
CPU와 주소 버스 사이에 위치한 MMU(Memory Management Unit, MMU)라는 하드웨어에서 수행

MMU는 CPU가 발생시킨 논리 주소에 베이스 레지스터 값을 더해서 논리 주소를 물리주소로 변환
베이스 레지스터는 프로그램의 가장 작은 물리 주소, 즉 프로그램의 첫 물리 주소를 저장
논리 주소는 프로그램의 시작점으로부터 떨어진 거리?

## 메모리 보호 기법
Limit Register(한계 레지스터)
- 논리 주소 범위를 벗어나는 명령어 실행을 방지
- 실행 중인 프로그램이 다른 프로그램에 영향을 받지 않도록 보호하는 역할

- 베이스 레지스터가 실행 중인 프로그램의 가장 작은 물리 주소를 저장, 한계 레지스터는 논리 주소의 최대 크기를 저장
베이스 레지스터 값 <= 프로그램의 물리 주소 범위 < 베이스 레지스터 + 한계 레지스터 값


# Cache Memory(캐시 메모리)
- CPU 연산속도 > CPU가 메모리에서 데이터를 가져다가 사용하는 속도
- CPU 연산속도가 아무리 빨라도 메모리에 접근하는 시간이 느리면 연산속도는 아무 쓸모가 없어짐
- 속도 차이를 극복하기 위해 **캐시 메모리**를 사용
- 

## Memory Hierarchy(저장 장치 계층 구조)

## Cache Memory(캐시 메모리)
- CPU와 메모리 사이에 위치하고 레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반의 저장 장치
- CPU의 연산 속도와 CPU의 메모리 접근 속도의 차이를 줄이기 위해 만들어짐
- 메모리에서 CPU가 사용할 일부 데이터를 미리 캐시 메모리로 가지고 와서 활용
- 캐시 메모리들은 CPU와 가까운 순서대로 계층을 구성함
- 코어와 가장 가까운 캐시 메모리를 L1, 그 다음 L2, 그 다음 L3 라고 부름
- 일반적으로 L1캐시, L2 캐시는 코어 내부에, L3 캐시는 코어 외부에 있음

## Split Cache(분리형 캐시) 
- 코어에 가장 가까운 L1 캐시는 조그밍라도 접근 속도를 빠르게 만들기 위해 명령어만을 저장하는 L1 캐시인 L1I(Instruction)캐시와
- 데이터만을 저장하는 L1 캐시인 L1D(Data) 캐시로 분리하는 경우가 많음

## Locality of Reference, Principle of Locality (참조 지역성 원리)
- 보조기억장치는 전원이 껴저도 기억할 대상을 저장
- 메모리는 실행 중인 프로그램을 저장
- 캐시 메모리는 CPU가 사용할만한 대상을 예측하여 저장
- 이 때 예측한 데이터가 실제로 맞아서 캐시 메모리 안의 데이터가 CPU에서 활용된 경우를 Cache Hit라고 함
- 반대로 예측에 틀려서 메모리에서 필요한 데이터를 직접 가져와야 하는 경우를 Chche Miss라고 함
- Chche Miss가 발생하면 캐시 메모리의 장점을 활용할 수 없음
- 캐시가 히트되는 비율을 Cache Hit Ratio 라고 함
- 캐시 히트 횟수 / 메모리에 접근하는 횟수(캐시 히트 횟수 + 캐시 미스 횟수)

### Temporal Locality(시간 지역성)
- 최근에 접근했던 메모리 공간에 다시 접근하려는 경향

### Spatial Locality(공간 지역성)

# 다양한 보조기억장치

## HDD(Hard Disk Drive)
- 자기적인 방식으로 데이터를 저장하는 보조기억장치
- 대용량 저장 장치가 필요한 작업에 주로 쓰임
- 동그란 원판에 데이터를 저장하고 그것을 회전시켜 뾰족한 리더기로 데이터를 읽음
- 동그란 원판 Platter(플래터), 자기 물질로 덮여 있어 수많은 N극과 S극을 저장 N극과 S극은 0과 1의 역할 수행
- 플래터를 회전 시키는 구성요소들 Spindle
- 플래터 분당 회전수 RPM(Revolution Per Minute)
- 플래터의 데이터를 읽고 쓰는 역할 Head, 플래터 위에 떠있는 바늘같이 생긴 부품
- 헤드를 원하는 위치로 이동시키는 Disk Arm
- 

## Reference
[혼자 공부하는 컴퓨터구조]()
