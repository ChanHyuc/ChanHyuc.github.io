---
title: "교착 상태"
categories: OS
---
## Deadlock(교착 상태)
- 프로세스를 실행하기 위해서는 자원이 필요한데 두 개 이상의 프로세스가 각자 가지고 있는 자원을 무작정 기다리면 
- 일어나지 않을 사건을 기다리며 진행이 멈춰 버리는 현상

## Dining Philosophers Problem(식사하는 철학자 문제)
![]({{site.url}}/images/DiningProblem.png)
- 음식을 먹기 위해서는 꼭 양손에 포크가 있어야 한다고 가정
- 왼쪽 포크가 있다면 왼쪽 포크를 들고 없다면 기다리고 오른쪽 포크가 있다면 오른쪽 포크를 들고 없다면 기다린다고 가정
- 철학자는 프로세스나 스레드, 포크는 자원을, 식사하는 것은 프로그램을 실행하는 것을 뜻함
- 한 두명이 식사를 할 수는 있지만 모든 철학자가 동시에 식사 할 수 없으며 계속 기다리는 상황이 발생할 수 있음
- 이렇게 일어나지 않을 사건을 기다리며 진행이 멈춰 버리는 현상을 **Deadlock(교착 상태)** 

## Resource-Allocation Graph(자원 할당 그래프)
![]({{site.url}}/images/ResourceGraph.png)
- 어떤 프로세스가 어떤 자원을 사용하고 있고, 어떤 자원을 기다리고 있는지 표현한 그래프
- 그림에서는 프로세스 A와 C가 CPU를 사용중이며 프로세스 B는 할당을 기다리고 있음
1. 프로세스는 원으로 자원의 종류는 사각형으로 표현
2. 사용할 수 있는 자원의 개수는 자원 사각형 내에 점으로 표현
3. 프로세스가 어떤 자원을 할당받아 사용 중이라면 자원에서 프로세스를 향해 화살표 표시
4. 프로세스가 어떤 자원을 기다리고 있다면 프로세스에서 자원으로 화살표 표시

## 교착 상태 발생 조건
- 4가지 중 하나라도 만족하지 않으면 교착 상태는 발생하지 않음
- 4가지 조건 모두 만족할 경우 교착 상태 **발생 가능성**이 있음

1. Mutual exclusion(상호 배제): 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 상태
2. Hold and Wait(점유와 대기): 자원을 할당 받은 상태에서 다른 자원을 할당 받기를 기다리는 상태
3. Nonpreemptive(비선점): 어떤 프로세스도 다른 프로세스의 자원을 강제로 뺏을 수 없는 상태
4. Circular Wait(원형 대기): 자원 할당 그래프가 원의 형태로 그려질 때 **발생할 수도 있음**

## 교착 상태 예방
- 교착 상태가 일어나기 전에 조건에 부합하지 않게(4가지 조건 중 하나를 없앰) 자원을 분배하여 예방함
- 교착상태가 발생하지 않음을 보장할 수 있지만 여러 부작용이 발생

### 자원의 상호배제를 없애기
- 자원의 상호 배제를 없앤다는건 모든 자원을 공유 가능하게 만든다는 뜻
- 이론상 교착 상태를 없앨 수 있지만 현실적으로 불가능

### 점유와 대기를 없애기
- 특정 프로세스에 자원을 모두 할당하거나, 아예 할당하지 않는 방식으로 점유와 대기를 없앨 수 있음
- 이론적으로 가능하지만 자원을 여러곳이 아닌 몇몇에게 몰아주기 때문에 자원의 활용률이 낮아지는 단점이 있음
- 자원을 많이 필요로 하는 프로세스가 무한정 기다리는 **기아 현상** 부작용이 있을 수 있음

### 비선점 조건을 없애기
- 비선점 조건을 없애면 자원을 이용 중인 프로세스로부터 자원을 빼앗을 수 있음
- 어느 정도 효과는 있지만 프로세스가 작업을 꼭 끝날때 까지 기다려야 하는 자원에는 조건을 사용할 수 없음 ex) 프린터
- 특정 자원이나 프로세스는 사용하지 못하기 때문에 범용성이 떨어지는 방법

### 원형 대기 조건을 없애기
- 모든 자원에 번호를 붙이고 오름차순(특정 조건)으로 자원을 할당하면 원형 대기 조건을 없앨 수 있음
- 컴퓨터 시스템 내에 수많은 자원에 번호를 붙여야 하는 단점이 있음

## 교착 상태 회피
- 교착 상태가 발생하지 않을정도로만 자원을 할당하는 방식
- 프로세스들에 배분할 수 있는 자원의 양을 고려해서 교착 상태가 발생하지 않을 정도의 양만큼만 자원을 배분하는 방법
- cf. 은행원 알고리즘

### Safe Sequence(안전 순서열)
- 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서

### Safe State(안전 상태)
- 안전 순서열이 있음
- 교착 상태가 발생하지 않고 모든 프로세스가 정상적으로 자원을 할당받고 종료될 수 있는 상태

### Unsafe State(불안정 상태)
- 안전 순서열이 없음
- 교착 상태가 발생할 수도 있는 상황

### 안전 상태 예시
1.P1, P2, P3가 모두 최대로 자원을 요구하는 최악의 상황이라고 가정할 때

|프로세스|요구량|현재 사용량|
|---|---|---|
|P1|10|5|
|P2|4|2|
|P3|9|2|

- 총 자원: 12
- 할당한 자원: 9
- 남은 자원: 3

2.일단 P2에 남은 자원에서 두 개를 분배

|프로세스|요구량|현재 사용량|
|---|---|---|
|P1|10|5|
|P2|4|2 + 2|
|P3|9|2|

- 할당한 자원: 9 + 2 = 11
- 남은 자원: 3 - 2 = 1

3.P2는 작업이 끝나고 자원을 반환함, 자원은 5개가 됨

|프로세스|요구량|현재 사용량|
|---|---|---|
|P1|10|5|
|~~P2~~|~~4~~|~~2 + 2~~|
|P3|9|2|

- 할당한 자원: 11 - 4 = 7
- 남은 자원: 1 + 4 = 5

4.P1에 남은 자원 5개를 할당하면 P1 작업도 완료할 수 있음

|프로세스|요구량|현재 사용량|
|---|---|---|
|P1|10|5 + 5|
|~~P2~~|~~4~~|~~2 + 2~~|
|P3|9|2|

- 할당한 자원: 7 + 5 = 12
- 남은 자원: 5 - 5 = 0

5.P1이 작업을 마치고 자원을 반환하면 P3에 자원을 할당하면 교착상태 없이 작업완료

|프로세스|요구량|현재 사용량|
|---|---|---|
|~~P1~~|~~10~~|~~5 + 5~~|
|~~P2~~|~~4~~|~~2 + 2~~|
|P3|9|2|

- 할당한 자원: 12 - 10 = 2
- 남은 자원: 0 + 10 = 10

## 교착 상태 검출 후 회복
- 교착 상태가 발생되고 나면 사후에 조치하는 방법
- OS는 프로세스들이 자원을 요구할 때마다 모두 할당하며 교착 상태 여부를 주기적으로 검사 
- 교착 상태가 검출되면 회복함

### 선점을 통한 회복
- 교착 상태가 해결 될 때 까지 하나의 프로세스씩 자원을 몰아주는 방법

### 프로세스 강제 종료를 통한 회복
- 가장 단순하면서 확실한 방법
- 교착상태에 놓인 모든 프로세스들을 강제 종료하는 방법, 교착 상태가 없어질 때까지 프로세스를 하나씩 강제 종료하는 방법이 있음
- 전자는 문제 해결을 확실하게 할 수 있지만 많은 프로세스들이 작업 내역을 잃게 될 가능성이 있음
- 후자는 잃게 될 작업 내역을 최대한 줄일 수 있지만 교착 상태가 없어졌는지 확인하는 과정에서 **오버헤드**가 발생할 수 있음

❗️**Ostrich Algorithm(타조 알고리즘)**
- 교착 상태를 무시하는 방법
- 완벽함을 추구해야하는 과학자나 수학자와 달리 최대 효율을 추구하는 엔지니어에게는 이것 또한 방법이 될 수 있음
- 문제 발생의 빈도나 심각성에 따라 무시하는게 효율적이라면 이 방법이 적할할 때도 많음


## Reference
[혼자 공부하는 컴퓨터구조]()
