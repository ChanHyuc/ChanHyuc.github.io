---
title: "CPU 스케줄링"
categories: OS
---
## CPU Scheduling
- 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것, 컴퓨터 성능과도 직결됨
- 프로세스들에게 CPU를 제대로 배분하지 못한다면 당장 급하게 실행되야 할게 실행되지 못하거나, 급하지 않은 프로세스들만 실행 되는 등의 **무질서한 상태**가 발생할 수 있음

### Priority(우선순위)
- 준비 상태가 된 여러 프로세스가 상황에 맞게, 프로세스의 중요도에 맞게 CPU를 이용할 수 있도록 운영체제는 **우선순위**를 정해야 함
- 우선 순위가 높을 수록 더 빨리 더 자주 실행됨, PCB에 우선순위를 명시 함
- 대부분의 프로세스들은 CPU와 입출력장치를 번갈아가며 실행함, 즉 프로세스는 실행 상태와 대기 상태를 반복하며 실행
    - ex) 메모장을 사용할 때
    - 1. 메모장은 CPU를 사용하여 명령어를 실행(CPU)
    - 2. 사용자로부터 입력받은 내용을 보조기억장치에 저장(입출력장치)
    - 3. CPU 명령어를 사용하여 명령어를 실행(CPU)
    - 4. 사용자가 입력한 내용을 화면에 출력...(입출력장치) 과정을 반복

**Bound Process**
- I/O Bound Process(입출력 집중 프로세스): 비디오 재생이나 디스크 백업 작업 등 입출력 작업이 많은 프로세스
- CPU Bound Process(CPU 집중 프로세스): 컴파일, 수학 연산, 그래픽 처리 작업 등 CPU 작업이 많은 프로세스
- 만약 **입출력 집중 프로세스**와 **CPU 집중 프로세스**가 동시에 CPU 자원을 요구할 경우
    - **입출력 집중 프로세스**를 빨리 실행시켜 입출력 장치를 끊임없이 작동시키고
    - 그 다음 **CPU 집중 프로세스**에 집중적으로 CPU를 할당하는 것이 효율적
    - 입출력장치가 입출력 작업을 완료하기 전까지는 어차피 대기 상태가 될 예정이기 때문
    
### Scheduling Queue(스케줄링 큐)
![]({{site.url}}/images/OS/SchedulingQueue.png)
- 운영체제가 매 순간 PCB를 살피며 우선순위를 검사하는 것은 비효율적인 일
- 그래서 운영체제는 CPU를 사용하고 싶은 프로세스, 메모리에 적재되고 싶은 프로세스, 입출력장치를 사용하고 싶은 프로세스 등등을 분류해서 관리
- 운영체제는 PCB들이 Queue에 삽입된 순서대로 하나씩 실행하되 우선순위가 높은 프로세스를 먼저 실행함
- Queue는 자료구조에서 선입선출이지만 스케줄링 큐는 반드시 선입선출일 필요는 없음

**프로세스 상태 다이어그램(Queue 포함)**
![]({{site.url}}/images/OS/ReadyWaitingQueue.png)
- Ready Queue(준비 큐): CPU를 이용하고 싶은 프로세스들
- Waiting Queue(대기 큐): 입출력장치를 이용하고 싶은 프로세스들

### Preemptive Scheduling(선점형 스케줄링)
- CPU나 memory같은 자원을 다른 프로세스가 사용하고 있더라도 운영체제가 **자원을 강제로 뺏어서** 다른 프로세스에 할당할 수 있는 스케줄링
- 자원의 **독점**을 막고 균등하게 자원을 배분할 수 있지만, 문맥 교환 과정에서 **오버헤드**가 발생할 수 있음

### Non-Preemptive Scheduling(비선점형 스케줄링)
- 자원을 사용하고 있는 프로세스가 있다면 그 프로세스가 종료되거나 대기 상태가 되기전까진 **다른 프로세스가 해당 자원을 사용할 수 없는** 스케줄링
- 문맥 교환의 횟수가 적기 때문에 오버헤드는 적게 발생하지만, **하나의 프로세스가 자원을 독점할 수 있음**

## CPU Scheduling Algorithm(CPU 스케줄링 알고리즘)
- 종류는 매우 다양하고 운영체제마다 서로 다른 스케줄링 알고리즘을 사용함
- 각각의 스케줄링 알고리즘은 '용어'가 아닌 '아이디어'이기 때문에 작동 방식과 장단점을 이해하는데 집중해야 함

### FCFS(First Come First Served Scheduling, 선입 선처리 스케줄링)
![]({{site.url}}/images/OS/FCFS.png)
- 단순히 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 **비선점형 스케줄링**
- Convoy Effect(호위 효과): 앞에 있는 프로세스가 길게 자원을 사용할 경우 뒤에 있는 프로세스들이 기다리는 시간이 길어진다는 단점이 있음
    
### SJF(Shortest Job First Scheduling, 최단 작업 우선 스케줄링)
![]({{site.url}}/images/OS/SJF.png)
- 호위 효과를 방지하기 위해 CPU 사용 시간이 짧은 프로세스 순으로 실행함
- **비선점형 스케줄링**이지만 **선점형**(선점형 최단 작업 우선 스케줄링)으로 구현될 수도 있음

### RR(Round Robin Scheduling)
![]({{site.url}}/images/OS/RR.png)
- FCFS(선입선처리)에 **Time Slice(타임 슬라이스)** 개념이 더해진 **선점형 스케줄링**
- Time Slice(타임 슬라이스): 프로세스가 CPU를 사용할 수 있는 시간
- Time Slice가 지나치게 크면 FCFS와 다를게 없어 **호위 효과**가 발생하고 지나치게 작다면 **문맥 교환**에 발생하는 비용이 커짐

### SRT(Shortest Remaining Time, 최소 잔여 시간 우선 스케줄링)
- SJF(최단 작업 우선 스케줄링)과 Round Robin 방식을 합친 **선점형 스케줄링**
- 프로세스들은 정해진 Time Slice만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택됨

### Priority Scheduling(우선순위 스케줄링)
- 프로세스들에게 우선순위를 정하고 **가장 높은 우선순위**를 가진 프로세스부터 실행하는 스케줄링(우선순위가 같을 경우 선입선처리)
- SJF, SRT는 넓은 의미에서 우선순위 스케줄링의 종류에 들어감, **기아 현상** 부작용이 있지만 **에이징**으로 방지할 수 있음
- Starvation(기아)현상: 우선순위가 낮은 프로세스는 먼저 큐에 삽입되었음에도 우선순위가 높은 프로세스들이 계속해서 실행될 경우 계속해서 연기되는 현상
- Aging(에이징): 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식  

### Multilevel Queue Scheduling(다단계 큐 스케줄링)
![]({{site.url}}/images/OS/MultilevelQueue.png)
- 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링
- 큐를 여러 개를 두면 프로세스 유형별로 우선순위를 구분해서 실행하는것이 편해짐
    - ex) 어떤 큐는 FCFS(선입선처리)만하고 어떤 큐에서는 RR만 하는것으로 분류
- 우선순위가 가장 높은 큐가 비어 있으면 그다음 우선순위 큐에 있는 프로세스들을 처리
- 큐를 여러개로 나누었어도 우선순위가 낮을 경우 기아현상이 발생할 수 있음

### Multilevel Feedback Queue Scheduling(다단계 피드백 큐 스케쥴링)
- 프로세스들이 **큐 사이를 이동할 수 없는** 다단계 큐 스케줄링을 보완해서 만든 스케줄링
- 구현이 복잡하지만 가장 일반적인 CPU 스케줄링 알고리즘
- 프로세스들이 큐 사이를 이동할 수 있기 때문에 낮은 우선순위 큐에서 오래 기다리고 있는 프로세스가 있다면 점차 높은 우선순위가 높을 큐로 이동해서 **에이징**을 사용하여 **기아 현상**을 방지할 수 있음

## Reference
[혼자 공부하는 컴퓨터구조]()
