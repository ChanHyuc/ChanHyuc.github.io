---
title: "프로세스와 스레드"
categories: OS
---
## Process(프로세스)
- 프로그램은 실행되기 전까지는 보조기억장치에 있는 데이터 덩어리일 뿐
- 프로그램을 메모리에 적재하고 실행되는 순간 프로그램은 프로세스가 됨
- Foreground Process: 사용자가 보는 앞에서 실행되는 프로세스
- Background Process: 사용자가 보지 못하는 뒤에서 실행되는 프로세스
    - 백그라운드 프로세스 중에서 사용자와 직접 상호작용할 수 있는 프로세스도 있지만 상호작용없이 정해진 일만 수행하는 프로세스도 있음
    - Unix 체계에서는 이를 **Demon**, Window 체계에서는 **Service**라고 함
 
### PCB(프로세스 제어 블록, Process Control Block)
- 프로세스와 관련된 정보를 저장하는 자료 구조
- 프로세스를 식별하기위해 꼭 필요한 정보들이 저장됨
- 커널 영역에 생성되고 커널 영역에서 사용함
- 프로세스 생성 시에 만들어지고 실행이 끝나면 폐기됨
 
### PCB에 담기는 정보 (운영체제마다 차이가 있음)
1. 프로세스 ID (PID): 프로세스를 식별하기 위해 부여하는 고유번호, 같은 일을 수행하는 프로그램이라도 두 번 실행하면 PID가 다른 두 개의 프로세스가 생성됨
2. 레지스터 값: 프로세스는 자신의 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원함, 그래야만 이전까지 진행했던 작업들을 이어서 실행할 수 있음
3. 프로세스 상태
4. 스케줄링 정보
5. 메모리 관리 정보
6. 사용한 파일과 입출력장치 목록
 
### Context Switching(문맥 교환)
- Context(문맥): 중간 정보 프로세스 수행을 이어서 하기 위해 기억해야할 정보
    - ex) CPU에 할당받아 실행되던 프로세스 A에서 프로세스 B로 CPU를 자원이 이동한다고 가정 했을 때 A는 중간 정보를 기억해야함
    - 그래야 다시 자신의 차례가 되었을 때 이전까지 실행했던 내용을 이어서 실행할 수 있기 때문
- Context Switching(문맥 교환): 기존 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구해서 새로운 프로세스를 실행하는 것
- 문맥 교환을 너무 자주 하면 오버헤드가 발생할 수 있음

![]({{site.url}}/images/OS/ContextSwitching.png)

## 프로세스 메모리 영역(사용자 영역)
### Code Segment(코드 영역, Text Segment)
- 실행할 수 있는 코드, 기계어로 된 명령어가 저장됨
- 데이터가 아닌 CPU가 실행할 명령어가 담겨 있기 때문에 쓰기가 금지됨(read-only)

### Data Segment(데이터 영역)
- 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간(Global Variable, 전역변수)
- 코드영역, 데이터 영역은 크기가 변하지 않음**(정적 할당 영역)**

### Heap Segment(힙 영역)
- 프로그래머가 직접 할당할 수 있는 저장 공간
- 메모리 공간을 할당했다면 프로그래머는 해당 공간을 반환해야 함
- 반환하지 않는다면 계속 사용하지 않는 공간이 남아 있어 **메모리 낭비 발생(Memory Leak(메모리 누수))**

### Stack Segment(스택 영역)
- 데이터 영역과 달리 잠깐 사용하는 값들이 저장 됨(데이터를 일시적으로 저장)
- 함수 실행이 끝나면 사라지는 매개변수나 지역변수가 있음
- 힙 영역과 스택 영역을 실시간으로 값이 변함**(동적 할당 영역)**
- 일반적으로 Heap 영역은 낮은주소 -> 높은주소, Stack 영역은 높은주소 -> 낮은주소로 설정해 주소가 겹치지 않도록 함

![]({{site.url}}/images/OS/Segment.png)

## Process State(프로세스 상태)
1. New(생성 상태)
- 지금 막 메모리에 적재되어 PCB를 할당받은 상태

2. Ready(준비 상태)
- CPU를 할당받아 실행할 수 있는 상태지만 자신의 차례가 아니여서 기다리는 상태
- Dispatch: 준비 상태에서 실행 상태로 전환되는 것

3. Running(실행 상태)
- CPU를 할당받아 실행중인 상태
- 할당된 시간에만 CPU를 사용할 수 있으며 작업이 끝나지 않았어도 시간이 다 되면 다시 **준비 상태**가 됨
- 실행 도중 입출력장치를 사용하여 입출력장치의 작업이 끝날 때까지 기다려야 한다면 **Blocked(대기 상태)**가 됨

4. Blocked(대기 상태)
- 특정 이벤트가 일어나길 기다릴 때 **(입출력 작업을 기다리는 상태)**
- 입출력 작업은 CPU에 비해 처리 속도가 느리기에 요청한 입출력 작업이 끝날 때까지 기다려야 함
- 입출력 작업이 완료되면 프로세스는 다시 **준비 상태**로 CPU 할당을 기다림

5. 종료 상태(Terminated)
- 프로세스가 종료된 상태, PCB와 프로세스가 사용한 메모리를 정리

**Process State Diagram(프로세스 상태 다이어그램)**
![]({{site.url}}/images/OS/ProcessStateDiagram.png)

### Process Hierarchy(프로세스 계층구조)
- 프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있음
- Parent Process: 새 프로세스를 생성한 프로세스
- Child Process: 부모 프로세스에 의해 생성된 프로세스
- PPID(Parent PID): 자식 프로세스의 PCB에 부모 프로세스의 PID를 기록
- 모든 프로세스의 가장 위에 있는 최초의 프로세스 Unix: init, Linux: systemd, macOS: launchd 라고 하며 PID는 항상 1번
- Window 운영체제는 계층구조를 사용하지 않음

### 프로세스 생성 기법
![]({{site.url}}/images/OS/ProcessCreate.png)
- fork: 자기 자신 프로세스의 **복사본**을 만드는 시스템 호출
- exec: 자신의 메모리 공간을 **새로운 프로그램으로 덮어쓰는** 시스템 호출
- 부모 프로세스는 **fork**를 통해 자신의 복사본을 자식 프로세스로 생성함
    - 복사본이기 때문에 프로세스의 자원들은 자식 프로세스에 상속됨(PID값이나 저장된 메모리 위치는 다름)
- 자식 프로세스는 **exec**를 통해 자신의 메모리 공간을 다른 프로그램으로 교체함
    - exec를 호출하면 코드 영역과 데이터 영역의 내용이 실행할 프로그램의 내용으로 바뀌고 나머지 영역은 초기화됨
- 부모 프로세스가 자식 프로세스를 fork한 뒤에 부모, 자식 프로세스 모두 exec를 호출 하지 않는 경우가 있음
    - 이 경우 부모, 자식 프로세스 모두 같은 코드를 병행하여 실행하는 프로세스

**프로세스가 생성되는 예시**
1. bash 셀에서 ls라는 명령어를 사용
2. bash 프로세스는 **fork**를 통해 자신과 동일한 프로세스(자식 프로세스)를 생성
3. 자식 프로세스는 **exec**를 통해 ls 명령어를 실행하기 위한 프로세스로 전환 되어 ls 명령어가 실행되기 위한 내용들로 채워짐

## Thread
- 프로세스를 구성하는 실행의 흐름 단위
- 하나의 프로세스는 여러개의 Thread를 가질 수 있으며, 스레드를 이용하면 하나의 프로세스로 여러 부분을 동시에 실행할 수 있음
- 단일스레드 프로세스: 하나의 프로세스는 한 번에 하나의 일만 처리
- 멀티스레드 프로세스: **스레드** 개념이 생기면서 하나의 프로세스가 한 번에 여러 일을 동시에 처리할 수 있게 됨

![]({{site.url}}/images/OS/ThreadStack.png)
- Thread 구성 요소: Thread ID(고유 번호), 프로그램 카운터를 비롯한 레지스터 값, 스택 등 **실행의 필요한 최소한의 정보**
- 프로세스를 이루는 스레드들은 프로세스의 자원들을 공유할 수 있음
- 최근 운영체제는 프로세스를 통째로 전달하기 보다는 스레드 단위로 CPU를 할당, 해제함

### MultiProcess와 MultiThread 
![]({{site.url}}/images/OS/MultiProcessThread.png)
- 예시와 같이 MultiProcess와 MultiThread는 같은 작업을 3개를 한다고 가정 했을 때 결과가 같음
- MultiProcess는 fork 하여 같은 작업을 하는 동일한 프로세스가 두 개가 실행됨, **자원을 공유하지 않고** 각자 자신의 자원이 있음
- MultiThread는 스레드 ID, 프로그램 카운터 값을 포함한 레지스터, 스택을 제외한 **자원을 공유함**

**MultiProcess**

![]({{site.url}}/images/OS/MultiProcess.png)
- 프로세스를 동시에 실행하는 것
- Code, Data, Heap 등 모든 자원이 복제되어 저장
- 그림과 같이 저장된 메모리 주소를 제외하면 모든 것이 동일한 프로세스 2개가 통째로 메모리에 적재
- 하나의 프로세스에 문제가 생겨도 다른 프로세스에는 지장이 적음

**MultiThread**

![]({{site.url}}/images/OS/MultiThread.png)
- 여러스레드로 프로세스를 동시에 실행하는 것
- Code, Data, Heap 등 프로세스가 가지는 자원을 공유, 자원을 공유하기 때문에 **통신에 유리**
- 하나의 스레드에 문제가 생기면 프로세스 전체에 문제가 생길 수 있음

### IPC(Inter- Process Communication, 프로세스 간 통신)
![]({{site.url}}/images/OS/IPC.png)
- 프로세스끼리 기본적으로 자원을 공유하지 않지만 자원을 공유하고 데이터를 주고 받을 수 있는 방법이 있음
- 프로세스들은 서로 공유하는 메모리 영역을 두어 데이터를 주고받는데 이 메모리 영역을 **Shared Memory(공유 메모리)**라 함
- 처음부터 모든 자원을 공유하는 스레드에 비하면 까다로움

## Reference
[혼자 공부하는 컴퓨터구조]()
