---
title: "프로세스와 스레드"
categories: OS
---
## Process(프로세스)
- 프로그램은 실행되기 전까지는 보조기억장치에 있는 데이터 덩어리일 뿐
- 프로그램을 메모리에 적재하고 실행되는 순간 프로그램은 프로세스가 됨
- Foreground Process: 사용자가 보는 앞에서 실행되는 프로세스
- Background Process: 사용자가 보지 못하는 뒤에서 실행되는 프로세스
    - 백그라운드 프로세스 중에서 사용자와 직접 상호작용할 수 있는 프로세스도 있지만 상호작용없이 정해진 일만 수행하는 프로세스도 있음
    - Unix 체계에서는 이것을 **Demon**, Window 체계에서는 **Service**라고 함
 
## Process Control Block(프로세스 제어 블록, PCB)
1. 프로세스와 관련된 정보를 저장하는 자료 구조
2. 프로세스를 식별하기위해 꼭 필요한 정보들이 저장됨
3. 커널 영역에 생성됨(커널영역에서 사용함)
4. 프로세스 생성 시에 만들어지고 실행이 끝나면 폐기됨
 
### PCB에 담기는 정보 (운영체제마다 차이가 있음)
1. 프로세스 ID (PID): 프로세스를 식별하기 위해 부여하는 고유번호, 같은 일을 수행하는 프로그램이라도 두 번 실행하면 PID가 다른 두 개의 프로세스가 생성됨
2. 레지스터 값: 프로세스는 자신의 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원함, 그래야만 이전까지 진행했던 작업들을 이어서 실행할 수 있음
3. 프로세스 상태
4. 스케줄링 정보
5. 매모리 관리 정보
6. 사용한 파일과 입출력장치 목록
 
### Context Switching(문맥 교환)
![]({{site.url}}/images/ContextSwitching.png)
- Context(문맥): 중간 정보 프로세스 수행을 이어서 하기 위해 기억해야할 정보
    - ex) CPU에 할당받아 실행되던 프로세스 A에서 프로세스 B로 CPU를 자원이 이동한다고 가정 했을 때 A는 중간 정보를 기억해야함
    - 그래야 다시 자신의 차례가 되었을 때 이전까지 실행했던 내용을 이어서 실행할 수 있기 때문
- Context Switching(문맥 교환): 기존 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구해서 새로운 프로세스를 실행하는 것
- 문맥 교환을 너무 자주 하면 오버헤드가 발생할 수 있음

## 프로세스 메모리 영역(사용자 영역)
### Code Segment(코드 영역, Text Segment)
- 실행할 수 있는 코드, 기계어로 된 명령어가 저장됨
- 데이터가 아닌 CPU가 실행할 명령어가 담겨 있기 때문에 쓰기가 금지됨(read-only)

### Data Segment(데이터 영역)
- 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간(Global Variable, 전역변수)
- 코드영역, 데이터 영역은 크기가 변하지 않음(정적 할당 영역) 

### Heap Segment(힙 영역)
- 프로그래머가 직접 할당할 수 있는 저장 공간
- 메모리 공간을 할당했다면 프로그래머는 해당 공간을 반환해야 함, 반환하지 않는다면 Memory Leak(메모리 누수) 발생

### Stack Segment(스택 영역)
- 데이터 영역과 달리 잠깐 사용하는 값들이 저장 됨(데이터를 일시적으로 저장)
- 함수 실행이 끝나면 사라지는 매개변수나 지역변수가 있음
- 힙 영역과 스택 영역을 실시간으로 값이 변함(동적 할당 영역)

![]({{site.url}}/images/Segment.png)
- 일반적으로 Heap 영역은 낮은주소 -> 높은주소, Stack 영역은 높은주소 -> 낮은주소로 설정해 주소가 겹치지 않도록 함

## Process State(프로세스 상태)
1. 생성 상태(New)
- 지금 막 메모리에 적재되어 PCB를 할당받은 상태

2. 준비 상태(Ready)
- CPU를 할당받아 실행할 수 있는 상태지만 자신의 차례가 아니여서 기다리는 상태
- 준비 상태에서 실행 상태로 전환되는 것을 Dispatch라고 함

3. 실행 상태(Running)
- CPU를 할당받아 실행중인 상태
- 할당된 시간에만 CPU를 사용할 수 있으며 시간이 다 되면 다시 준비 상태가 됨
- 실행 도중 입출력장치를 사용하여 입출력장치의 작업이 끝날 때까지 기다려야 한다면 대기 상태가 됨

4. 대기 상태(Blocked)
- 특정 이벤트가 일어나길 기다릴 때(대부분은 입출력 작업으로 대기 상태가 됨)
- 입출력 작업은 CPU에 비해 처리 속도가 느리기에 요청한 입출력 작업이 끝날 때까지 기다려야 함
- 입출력 작업이 완료되면 프로세스는 다시 준비 상태로 CPU 할당을 기다림

5. 종료 상태(Terminated)
- 프로세스가 종료된 상태, PCB와 프로세스가 사용한 메모리를 정리

### Process State Diagram(프로세스 상태 다이어그램)
![]({{site.url}}/images/ProcessStateDiagram.png)

## Process Hierarchy(프로세스 계층구조)
- 프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있음
- Parent Process: 새 프로세스를 생성한 프로세스
- Child Process: 부모 프로세스에 의해 생성된 프로세스
- PPID(Parent PID): 자식 프로세스의 PCB에 부모 프로세스의 PID를 기록
- 모든 프로세스의 가장 위에 있는 최초의 프로세스 Unix: init, Linux: systemd, macOS: launchd 라고 하며 PID는 항상 1번

## 프로세스 생성 기법

## Reference
[혼자 공부하는 컴퓨터구조]()
