---
title: "Git & GitHub"
categories: Git
---
## Git이 없다면?
- 변경 내역을 확인하기 어려움
    - 하나의 파일을 변경하고 덮어서 저장한다면 파일의 최신화 상태만 가질 수 있게 됨 (변경 사항을 알 수 없음)
    - 매번 파일을 변경할 때 마다 다른 이름으로 저장한다면 과거의 변경사항을 알 수 있게되지만 저장 공간을 낭비하게 됨
- 버전을 되돌리기 어려움
- 협력하기 어려움

## Version
- 기능이 새로 추가, 삭제되거나 버그가 수정되는 등 기존과의 다른 유의미한 변화가 생겼을 때 만들어 짐
- 버전 관리란?
    - 누가 어떻게 변경 했는지 내역을 기억함
    - 필요하다면 특정 시점으로 버전을 되돌림
    - 여러 명이 협업하는 코드를 나누고 합침

## Git
- 버전 관리를 도와주는 소프트웨어. Version Control System, VCS(버전 관리 시스템)
- Linus Torvalds가 만든 오픈 소스 프로젝트.

## GitHub
- 원격 저장소 호스팅 서비스

## 버전 관리하는 세 개의 공간

### working directory(작업 공간)
- 버전 관리의 대상이 위치 하는 공간
- 변경 사항을 만드는 곳
- 작업 공간에서 변경 사항이 생기는 순간 새로운 버전을 만들 수 있음 (파일이 생성, 수정, 삭제 되었을 경우)

### stage(스테이지)
- 변경 사항 중에서 모든 변경 사항을 새로운 버전에 꼭 포함할 필요는 없음
- 새로운 버전으로 만들만큼 중요하지 않거나, 임시로 또는 실수로 변경 했을 수도 있기 때문
- 그래서 변경된 파일 중 새로운 버전이 될 파일들을 골라내서 특별한 공간으로 옮기는 작업을 거치는데 **이 공간이 stage**
- 즉 다음 버전이 될 후보가 올라가는 공간
- **작업 공간**에서 **stage**로 옮길 때 **add** 명령어를 사용
- **stage**에서 새로운 버전을 만드는 것을 commit이라고 표현하고 **commit** 명령어를 사용
- **작업 공간**은 내가 지금 작업하고 있는 공간이고 **저장 공간** 깃허브 홈페이지에서 눈으로 각각 직접 확인할 수 있지만 stage는 명시적으로 보이지 않음 

### repository(저장 공간)
- **stage** 파일을 바탕으로 새로운 버전을 만들면 새 버전이 저장소에 추가됨
- **작업 공간**에서 만들어진 모든 버전들의 내역은 저장소에 있음
- 새 버전이 추가 되면 **stage**는 깨끗하게 비워짐

## commit message
- 버전을 설명하는 메시지
- 누가 언제 파일을 변경했는지를 알 수 있고 파일을 어떻게 왜 변경했는지 등의 설명을 기술함
- 각각의 커밋에는 고유한 커밋해시가 있음
- 커밋해시는 **무작위 문자열**과 같아서 가독성이 좋지 못하기 때문에 중요한 커밋은 **tag**를 붙임
- tag에는 보통 사용자에게 배포할(release)할 버전을 명시함 

untracked
- 기존에 깃이 추적하지 않았던 파일 (기존에 깃이 관리하지 않았던 파일)
tracked
- 기존에 깃이 변경 사항을 추적하고 있는 파일 (stage에 한 번이라도 커밋된 적 있는 파일)
release
- 개발한 소프트웨어를 사용자에게 배포하는 것

## 버전 표기법
- 버전 표기 방법은 개발자마다 정하기 나름 <연도,월,일>, <숫자.숫자.숫자> 형태로 명시하기도 함
- 대중적인 버전 표기법 vX. Y. Z
- X 주(Major) 버전
- 기존에 내놓은 버전과 호환되지 않을 정도로 큰 변화가 있을 때 증가
- Y 부(Minor) 버전
- 일반적으로 새롭게 내놓은 버전이 기존에 내놓은 버전과 문제없이 호환되지만 새로운 기능을 추가했을 때 증가
- Z 수(Patch) 버전
- 기존에 내놓은 버전과 문제없이 호환되며 버그를 수정한 정도의 작은 변화가 있을 때 증가

## gitignore
- 변경 사항이 생기더라도 앞으로 계속 버전에 포함하고 싶지 않는 파일이나 폴더를 설정함
- .gitignore 파일을 만들고 무시하고 싶은 파일을 명시해서 기술하거나 ex) test.swift 폴더 이름을 기술함 ex) ignore/

## git stash
![stash]({{site.url}}/images/stash_before.png)
![stash]({{site.url}}/images/stash_after.png)
- 임시 저장 기능 (여러 개를 임시 저장할 수 있음)
- 사용하게 될 경우 **작업 디렉터리**에서 모든 변경 사항은 임시 저장되고 **작업 디렉터리**는 최근 커밋했던 기준으로 깨끗한 상태로 돌아감
- stash는 **stage**에 이미 올라와 있거나 한번이라도 **커밋**한적이 있는 파일에만 사용할 수 있음(**tracked**)
- 즉 방금 막 생성한 파일처럼 추적하지 않는 파일(**untracked**)은 사용할 수 없음

## branch
- 버전을 여러 흐름으로 나누어 관리함
    - 브랜치를 나눔
    - 각각의 브랜치에서 작업함
    - 필요한 경우 나눈 브랜치를 합침
- Git은 최초의 브랜치 master를 default로 사용, GitHub는 main을 default로 사용
- HEAD는 현재 작업 중인 브랜치의 **최신 커밋**을 가리킴
- 브랜치를 나누고 합치는 과정에서 HEAD의 위치를 자유롭게 바꿀 수 있음
- checkout하게 되면 HEAD의 위치가 해당 브랜치의 최신 커밋을 가리키고 **작업 디렉터리**는 체크아웃한 브랜치의 환경으로 바뀌게 됨
- 브랜치를 하나로 병합하는 것을 merge
- 빨리 감기 병합(fast-forward merge)
- 충돌: 병합하려는 두 브랜치가 **서로 같은 내용을 다르게 수정한 상황**
- 충돌은 여러명이 협업할 경우 빈번하게 발생하고 발생하면 브랜치가 병합되지 못함
- 그래서 왜 발생하고 어떻게 해결할 수 있는지 알아야 함
- 충돌이 발생한 파일들은 충돌을 해결한 뒤 다시 커밋해야 브랜치가 병합됨
- 충돌을 해결한다: 같은 내용을 다르게 수정한 브랜치 중 어떤 브랜치를 반영할 것인지 선택함
- 충돌이 발생한 파일에는 <<<<<, >>>>>, ===== 기호가 표기 됨
- <<<<<와 ===== 기호 사이의 내용을 선택할지 =====와 >>>>> 기호 사이의 내용을 선택할지 골라야 함

## rebase
![rebase]({{site.url}}/images/rebase_before.png)
![rebase]({{site.url}}/images/rebase_after.png)

- 브랜치가 뻗어나온 기준점을 변경하는 것

버전 vs 패치 vs 업데이트
