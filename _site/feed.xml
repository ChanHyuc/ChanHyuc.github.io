<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-08T21:26:54+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">DevOps</title><subtitle>기억하지 않고 기록하기</subtitle><author><name>ChanHyuk</name><email>whk1140@gmail.com</email></author><entry><title type="html">파일 시스템</title><link href="http://localhost:4000/os/%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C/" rel="alternate" type="text/html" title="파일 시스템" /><published>2024-01-07T00:00:00+09:00</published><updated>2024-01-07T00:00:00+09:00</updated><id>http://localhost:4000/os/%ED%8C%8C%EC%9D%BC%20%EC%8B%9C%EC%8A%A4%ED%85%9C</id><content type="html" xml:base="http://localhost:4000/os/%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C/"><![CDATA[<h2 id="file">File</h2>
<ul>
  <li>HDD나 SSD 같은 보조기억장치에 저장된 정보의 집합</li>
  <li>모든 파일에는 이름, 파일을 실행하기 위한 정보, <strong>파일 관련 부가 정보</strong>가 있음</li>
  <li><strong>파일 관련 부가 정보</strong>는 attribute 또는 metadata 라고 부름</li>
</ul>

<h3 id="파일-속성과-유형">파일 속성과 유형</h3>

<table>
  <thead>
    <tr>
      <th>속성 이름</th>
      <th>의미</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>유형</td>
      <td>OS가 인지하는 파일의 종류 ex) exe(Window) dmg(Mac)</td>
    </tr>
    <tr>
      <td>크기</td>
      <td>파일의 현재 크기와 허용 가능한 최대 크기</td>
    </tr>
    <tr>
      <td>보호</td>
      <td>어떤 사용자가 파일을 읽고 쓰고 실행할 수 있는지 나타냄</td>
    </tr>
    <tr>
      <td>생성 날짜</td>
      <td>파일에 생성된 날짜</td>
    </tr>
    <tr>
      <td>마지막 접근 날짜</td>
      <td>파일에 마지막으로 접근한 날짜</td>
    </tr>
    <tr>
      <td>마지막 수정 날짜</td>
      <td>파일에 마지막으로 수정한 날짜</td>
    </tr>
    <tr>
      <td>생성자</td>
      <td>파일을 생성한 사용자</td>
    </tr>
    <tr>
      <td>소유자</td>
      <td>파일을 소유한 사용자</td>
    </tr>
    <tr>
      <td>위치</td>
      <td>파일의 보조기억장치상의 현재 위치</td>
    </tr>
  </tbody>
</table>

<h3 id="file-시스템-호출">File 시스템 호출</h3>
<ul>
  <li>파일을 다루는 모든 작업은 OS의해 이뤄짐</li>
  <li>어떤 응용 프로그램도 임의로 파일을 조작할 수 없으며 파일을 다루려면 OS에 부탁해야 됨</li>
  <li>파일 생성, 삭제, 열기, 닫기, 읽기, 쓰기</li>
</ul>

<h2 id="directory">Directory</h2>
<h3 id="single-level-directory1단계-디렉터리">Single-level Directory(1단계 디렉터리)</h3>
<ul>
  <li>옛날 OS는 하나의 디렉터리만 존재</li>
  <li>모든 파일이 하나의 디렉터리 아래에 있었음</li>
</ul>

<h3 id="tree-structured-directory">Tree-structured Directory</h3>
<ul>
  <li>1단계 디렉터리로는 많은 파일을 관리하기 어렵기 때문에 생겨남</li>
  <li>최상위 디렉터리가 있고 아래에 여러 서브 디렉터리가 있음</li>
  <li>최상위 디렉터리는 root directory라고 부르고 / 로 표현</li>
</ul>

<h3 id="directory-시스템-호출">Directory 시스템 호출</h3>
<ul>
  <li>디렉터리 생성, 삭제, 열기, 닫기, 읽기</li>
</ul>

<h3 id="directory-entry">Directory Entry</h3>
<ul>
  <li>OS는 디렉터리도 파일로 취급함, 단지 포함된 정보가 조금 특별할 뿐</li>
  <li>파일 내부는 파일과 관련된 정보를 담고 있다면, 디렉터리는 자신이 담고 있는 대상과 관련된 정보를 담고 있음</li>
  <li>그리고 관련된 정보들은 Table(표)형태로 구성되며, 디렉터리는 보조기억장치에 테이블 형태로 정보가 저장됨</li>
</ul>

<h2 id="path경로">Path(경로)</h2>
<h3 id="absolute-path절대-경로">Absolute Path(절대 경로)</h3>
<ul>
  <li>루트 디렉터리에서 자기 자신까지 이르는 고유한 경로
    <h3 id="relative-path상대-경로">Relative Path(상대 경로)</h3>
  </li>
  <li>루드 디렉터리에서 시작하는게 아닌 현재 디렉터리부터 시작하는 경로</li>
</ul>

<h2 id="파일-시스템">파일 시스템</h2>

<h3 id="partitioning파티셔닝">Partitioning(파티셔닝)</h3>
<ul>
  <li>저장 장치의 논리적인 영역을 구획하는 작업
    <h3 id="partition">Partition</h3>
  </li>
  <li>파티셔닝으로 나누어진 영역
    <h3 id="formatting">Formatting</h3>
  </li>
  <li>파일 시스템을 설정하여 어떤 방식으로 파일을 저장하고 관리할 것인지 설정하고 새로운 데이터를 쓸 준비를 함</li>
  <li>어떤 종류의 파일 시스템을 사용할지 이때 결정함</li>
</ul>

<h2 id="파일-할당-방법">파일 할당 방법</h2>
<ul>
  <li>HDD의 가장 작은 저장 단위는 Sector, OS는 파일과 디렉터리를 Block 단위로 읽고 씀</li>
  <li>파일 시스템이 Sector를 사용하기에는 개수가 너무 많고 크기가 작음(그래서 Block 단위로 사용)</li>
</ul>

<h3 id="contiguous-allocation연속-할당">Contiguous Allocation(연속 할당)</h3>
<ul>
  <li>가장 단순한 방식, 보조기억장치 내 연속적으로 블록에 파일을 할당</li>
  <li>할당된 파일을 찾을 때는 파일의 첫번째 블록 주소와, 블록 단위의 길이만 알면 됨</li>
  <li><strong>외부 단편화</strong>를 야기한다는 단점이 있음</li>
</ul>

<h2 id="reference">Reference</h2>
<p><a href="">혼자 공부하는 컴퓨터구조</a></p>]]></content><author><name>ChanHyuk</name><email>whk1140@gmail.com</email></author><category term="OS" /><summary type="html"><![CDATA[File HDD나 SSD 같은 보조기억장치에 저장된 정보의 집합 모든 파일에는 이름, 파일을 실행하기 위한 정보, 파일 관련 부가 정보가 있음 파일 관련 부가 정보는 attribute 또는 metadata 라고 부름]]></summary></entry><entry><title type="html">가상 메모리</title><link href="http://localhost:4000/os/%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC/" rel="alternate" type="text/html" title="가상 메모리" /><published>2024-01-06T00:00:00+09:00</published><updated>2024-01-06T00:00:00+09:00</updated><id>http://localhost:4000/os/%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC</id><content type="html" xml:base="http://localhost:4000/os/%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC/"><![CDATA[<h2 id="연속-메모리-할당">연속 메모리 할당</h2>
<ul>
  <li>연속적인 메모리 공간을 할당하는 방식</li>
</ul>

<h3 id="swapping스와핑">Swapping(스와핑)</h3>
<ul>
  <li>메모리에 적재된 프로세스 중에서 현재 실행되지 않는 프로세스가 있을 수 있음</li>
  <li>이러한 프로세스들은 임시로 보조기억장치에 보내고 그렇게 해서 생긴 메모리상의 빈 공간에 또 다른 프로세스를 적재하는 방식
    <ol>
      <li>Swap Space: 이때 프로세스들이 쫒겨나는 보조기억장치의 일부 영역</li>
      <li>Swap-out: 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것</li>
      <li>Swap-in: 반대로 스왑 영역에서 프로세스가 다시 메모리로 옮겨지는 것</li>
    </ol>
  </li>
</ul>

<h2 id="메모리-할당">메모리 할당</h2>
<h3 id="first-fit최초-적합">First Fit(최초 적합)</h3>
<ul>
  <li>OS가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식</li>
  <li>적재할 수 있는 공간을 발견 즉시 할당하는 방식으로 검색을 최소화하고 빠른 할당이 가능
    <h3 id="best-fit최적-적합">Best Fit(최적 적합)</h3>
  </li>
  <li>OS가 빈 공간을 전부 검색 후에 프로세스가 적재할 수 있는 공간 중에서 가장 작은 공간에 배치하는 방식
    <h3 id="worst-fit최악-적합">Worst Fit(최악 적합)</h3>
  </li>
  <li>OS가 빈 공간을 전부 검색 후에 프로세스가 적재할 수 있는 공간 중에서 가장 큰 공간에 배치하는 방식</li>
</ul>

<h2 id="external-fragmentation외부-단편화">External Fragmentation(외부 단편화)</h2>
<ul>
  <li>프로세스들이 실행되고 종료되기를 반복하며 메모리 사이 사이에 빈 공간들이 생김</li>
  <li>전체의 빈 공간의 양보다 적은 메모리양만 적재할 수도 있게됨(메모리 낭비)</li>
</ul>

<h3 id="compaction압축">Compaction(압축)</h3>
<ul>
  <li>메모리 조각 모음</li>
  <li>여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식</li>
  <li>메모리 내에 저장된 프로세스를 재배치시켜서 여기저기 흩어져 있는 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법</li>
  <li>작은 빈 공간을 하나로 모으는 동안 시스템은 하던 일을 중지해야 한다는 단점이 있음</li>
  <li>메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기함</li>
</ul>

<h2 id="reference">Reference</h2>
<p><a href="">혼자 공부하는 컴퓨터구조</a></p>]]></content><author><name>ChanHyuk</name><email>whk1140@gmail.com</email></author><category term="OS" /><summary type="html"><![CDATA[연속 메모리 할당 연속적인 메모리 공간을 할당하는 방식]]></summary></entry><entry><title type="html">교착 상태</title><link href="http://localhost:4000/os/%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C/" rel="alternate" type="text/html" title="교착 상태" /><published>2024-01-05T00:00:00+09:00</published><updated>2024-01-05T00:00:00+09:00</updated><id>http://localhost:4000/os/%EA%B5%90%EC%B0%A9%20%EC%83%81%ED%83%9C</id><content type="html" xml:base="http://localhost:4000/os/%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C/"><![CDATA[<h2 id="deadlock교착-상태">Deadlock(교착 상태)</h2>
<ul>
  <li>프로세스를 실행하기 위해서는 자원이 필요한데 두 개 이상의 프로세스가 각자 가지고 있는 자원을 무작정 기다리면</li>
  <li>일어나지 않을 사건을 기다리며 진행이 멈춰 버리는 현상</li>
</ul>

<h2 id="dining-philosophers-problem식사하는-철학자-문제">Dining Philosophers Problem(식사하는 철학자 문제)</h2>
<ul>
  <li>음식을 먹기 위해서는 꼭 양손에 포크가 있어야 한다고 가정</li>
  <li>왼쪽 포크가 있다면 왼쪽 포크를 들고 없다면 기다리고 오른쪽 포크가 있다면 오른쪽 포크를 들고 없다면 기다린다고 가정</li>
  <li>한 두명이 식사를 할 수는 있지만 모든 철학자가 동시에 식사 할 수 없음</li>
  <li>철학자는 프로세스나 스레드, 포크는 자원을, 식사하는 것은 프로그램을 실행하는 것을 뜻함</li>
</ul>

<h2 id="resource-allocation-graph자원-할당-그래프">Resource-Allocation Graph(자원 할당 그래프)</h2>
<ul>
  <li>어떤 프로세스가 어떤 자원을 사용하고 있고, 어떤 자원을 기다리고 있는지 표현한 그래프</li>
</ul>

<ol>
  <li>프로세스는 원으로 자원의 종류는 사각형으로 표현</li>
  <li>사용할 수 있는 자원의 개수는 자원 사각형 내에 점으로 표현</li>
  <li>프로세스가 어떤 자원을 할당받아 사용 중이라면 자원에서 프로세스를 향해 화살표 표시</li>
  <li>프로세스가 어떤 자원을 기다리고 있다면 프로세스에서 자원으로 화살표 표시</li>
</ol>

<h2 id="교착-상태-발생-조건">교착 상태 발생 조건</h2>
<ul>
  <li>4가지 중 하나라도 만족하지 않으면 교착 상태는 발생하지 않음</li>
  <li>4가지 조건 모두 만족할 경우 교착 상태 발생 가능성이 있음</li>
</ul>

<ol>
  <li>Mutual exclusion(상호 배제): 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 상태</li>
  <li>Hold and Wait(점유와 대기): 자원을 할당 받은 상태에서 다른 자원을 할당 받기를 기다리는 상태</li>
  <li>Nonpreemptive(비선점): 어떤 프로세스도 다른 프로세스의 자원을 강제로 뺏을 수 없는 상태</li>
  <li>Circular Wait(원형 대기): 자원 할당 그래프가 원의 형태로 그려질 때 <strong>발생할 수도 있음</strong></li>
</ol>

<h2 id="교착-상태-예방">교착 상태 예방</h2>
<ul>
  <li>교착 상태가 일어나기 전에 조건에 부합하지 않게(4가지 조건 중 하나를 없앰) 자원을 분배하여 예방함</li>
  <li>교착상태가 발생하지 않음을 보장할 수 있지만 여러 부작용이 발생</li>
</ul>

<h3 id="자원의-상호배제를-없애기">자원의 상호배제를 없애기</h3>
<ul>
  <li>자원의 상호 배제를 없앤다는건 모든 자원을 공유 가능하게 만든다는 뜻</li>
  <li>이론상 교착 상태를 없앨 수 있지만 현실적으로 불가능</li>
</ul>

<h3 id="점유와-대기를-없애기">점유와 대기를 없애기</h3>
<ul>
  <li>특정 프로세스에 자원을 모두 할당하거나, 아예 할당하지 않는 방식으로 점유와 대기를 없앨 수 있음</li>
  <li>이론적으로 가능하지만 자원을 여러곳이 아닌 몇몇에게 몰아주기 때문에 자원의 활용률이 낮아지는 단점이 있음</li>
  <li>자원을 많이 필요로 하는 프로세스가 무한정 기다리는 <strong>기아 현상</strong> 부작용이 있을 수 있음</li>
</ul>

<h3 id="비선점-조건을-없애기">비선점 조건을 없애기</h3>
<ul>
  <li>비선점 조건을 없애면 자원을 이용 중인 프로세스로부터 자원을 빼앗을 수 있음</li>
  <li>어느 정도 효과는 있지만 프로세스가 작업을 꼭 끝날때 까지 기다려야 하는 자원에는 조건을 사용할 수 없음 ex) 프린터</li>
  <li>특정 자원이나 프로세스는 사용하지 못하기 때문에 범용성이 떨어지는 방법</li>
</ul>

<h3 id="원형-대기-조건을-없애기">원형 대기 조건을 없애기</h3>
<ul>
  <li>모든 자원에 번호를 붙이고 오름차순(특정 조건)으로 자원을 할당하면 원형 대기 조건을 없앨 수 있음</li>
  <li>컴퓨터 시스템 내에 수많은 자원에 번호를 붙여야 하는 단점이 있음</li>
</ul>

<h2 id="교착-상태-회피">교착 상태 회피</h2>
<ul>
  <li>교착 상태가 발생하지 않을정도로만 자원을 할당하는 방식</li>
  <li>프로세스들에 배분할 수 있는 자원의 양을 고려해서 교착 상태가 발생하지 않을 정도의 양만큼만 자원을 배분하는 방법</li>
  <li>cf. 은행원 알고리즘</li>
</ul>

<h3 id="safe-sequence안전-순서열">Safe Sequence(안전 순서열)</h3>
<ul>
  <li>교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서</li>
  <li>안전 상태는 안전 순서열이 있고, 불안전 상태는 안전 순서열이 없음</li>
</ul>

<h3 id="safe-state안전-상태">Safe State(안전 상태)</h3>
<ul>
  <li>교착 상태가 발생하지 않고 모든 프로세스가 정상적으로 자원을 할당받고 종료될 수 있는 상태</li>
</ul>

<h3 id="unsafe-state불안정-상태">Unsafe State(불안정 상태)</h3>
<ul>
  <li>교착 상태가 발생할 수도 있는 상황</li>
</ul>

<h2 id="교착-상태-검출-후-회복">교착 상태 검출 후 회복</h2>
<ul>
  <li>교착 상태가 발생되고 나면 사후에 조치하는 방법</li>
  <li>OS는 프로세스들이 자원을 요구할 때마다 모두 할당하며 교착 상태 여부를 주기적으로 검사</li>
  <li>교착 상태가 검출되면 회복함</li>
</ul>

<h3 id="선점을-통한-회복">선점을 통한 회복</h3>
<ul>
  <li>교착 상태가 해결 될 때 까지 하나의 프로세스씩 자원을 몰아주는 방법</li>
</ul>

<h3 id="프로세스-강제-종료를-통한-회복">프로세스 강제 종료를 통한 회복</h3>
<ul>
  <li>가장 단순하면서 확실한 방법</li>
  <li>교착상태에 놓인 모든 프로세스들을 강제 종료하는 방법, 교착 상태가 없어질 때까지 프로세스를 하나씩 강제 종료하는 방법이 있음</li>
  <li>전자는 문제 해결을 확실하게 할 수 있지만 많은 프로세스들이 작업 내역을 잃게 될 가능성이 있음</li>
  <li>후자는 잃게 될 작업 내역을 최대한 줄일 수 있지만 교착 상태가 없어졌는지 확인하는 과정에서 <strong>오버헤드</strong>가 발생할 수 있음</li>
</ul>

<p>❗️<strong>Ostrich Algorithm(타조 알고리즘)</strong></p>
<ul>
  <li>교착 상태를 무시하는 방법</li>
  <li>완벽함을 추구해야하는 과학자나 수학자와 달리 최대 효율을 추구하는 엔지니어에게는 이것 또한 방법이 될 수 있음</li>
  <li>문제 발생의 빈도나 심각성에 따라 무시하는게 효율적이라면 이 방법이 적할할 때도 많음</li>
</ul>

<h2 id="reference">Reference</h2>
<p><a href="">혼자 공부하는 컴퓨터구조</a></p>]]></content><author><name>ChanHyuk</name><email>whk1140@gmail.com</email></author><category term="OS" /><summary type="html"><![CDATA[Deadlock(교착 상태) 프로세스를 실행하기 위해서는 자원이 필요한데 두 개 이상의 프로세스가 각자 가지고 있는 자원을 무작정 기다리면 일어나지 않을 사건을 기다리며 진행이 멈춰 버리는 현상]]></summary></entry><entry><title type="html">프로세스 동기화</title><link href="http://localhost:4000/os/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94/" rel="alternate" type="text/html" title="프로세스 동기화" /><published>2024-01-04T00:00:00+09:00</published><updated>2024-01-04T00:00:00+09:00</updated><id>http://localhost:4000/os/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EB%8F%99%EA%B8%B0%ED%99%94</id><content type="html" xml:base="http://localhost:4000/os/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94/"><![CDATA[<h2 id="synchronization동기화">Synchronization(동기화)</h2>
<ul>
  <li>동시다발적으로 실행되는 프로세스들은 서로 협력하며 영향을 주고 받음</li>
  <li>이렇게 협력하여 실행되는 프로세스들은 실행 순서와 자원의 일관성을 보장해야 하기에 반드시 동기화가 필요함</li>
</ul>

<h3 id="실행-순서-제어를-위한-동기화">실행 순서 제어를 위한 동기화</h3>
<ul>
  <li>값을 저장하는 프로세스 A와 저장한 값을 읽는 프로세스 B가 있다고 가정</li>
  <li>두 프로세스는 순서 없이 실행되어선 안됨</li>
  <li>저장하는 프로세스 A가 실행되고 끝나서야 프로세스 B가 실행될 수 있기 때문</li>
</ul>

<h3 id="상호-배제를-위한-동기화">상호 배제를 위한 동기화</h3>
<ul>
  <li>Mutual Exclusion(상호 배제)는 공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘</li>
</ul>

<h2 id="shared-resource공유-자원">Shared Resource(공유 자원)</h2>

<h2 id="critical-section임계-구역">Critical Section(임계 구역)</h2>

<h2 id="reference">Reference</h2>
<p><a href="">혼자 공부하는 컴퓨터구조</a></p>]]></content><author><name>ChanHyuk</name><email>whk1140@gmail.com</email></author><category term="OS" /><summary type="html"><![CDATA[Synchronization(동기화) 동시다발적으로 실행되는 프로세스들은 서로 협력하며 영향을 주고 받음 이렇게 협력하여 실행되는 프로세스들은 실행 순서와 자원의 일관성을 보장해야 하기에 반드시 동기화가 필요함]]></summary></entry><entry><title type="html">CPU 스케줄링</title><link href="http://localhost:4000/os/CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/" rel="alternate" type="text/html" title="CPU 스케줄링" /><published>2024-01-03T00:00:00+09:00</published><updated>2024-01-03T00:00:00+09:00</updated><id>http://localhost:4000/os/CPU%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81</id><content type="html" xml:base="http://localhost:4000/os/CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/"><![CDATA[<h2 id="cpu-scheduling">CPU Scheduling</h2>
<ul>
  <li>운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것</li>
  <li>컴퓨터 성능과도 직결됨</li>
  <li>프로세스들에게 CPU를 제대로 배분하지 못한다면</li>
  <li>당장 급하게 실행되는게 실행되지 못하거나, 급하지 않은 프로세스들만 실행 되는 등의 <strong>무질서한 상태</strong>가 발생할 수 있음</li>
</ul>

<h2 id="priority우선순위">Priority(우선순위)</h2>
<ul>
  <li>우선순위가 높은 프로세스란 빨리 처리해야 하는 프로세스를 의미</li>
  <li>대부분의 프로세스들은 CPU와 입출력장치를 번갈아가며 실행함</li>
  <li>즉 프로세스는 실행 상태와 대기 상태를 반복하며 실행</li>
  <li>
    <p>ex) 메모장은 CPU를 사용하여 명령어를 실행하고, 사용자로부터 입력받은 내용을 보조기억장치에 저장하고 CPU 명령어를 사용하여 명령어를 실행하고 사용자가 입력한 내용을 화면에 출력하고… 과정을 반복</p>
  </li>
  <li>그런데 프로세스마다 입출력장치의 이용시간과 CPU 이용시간에는 차이가 있음</li>
</ul>

<h2 id="reference">Reference</h2>
<p><a href="">혼자 공부하는 컴퓨터구조</a></p>]]></content><author><name>ChanHyuk</name><email>whk1140@gmail.com</email></author><category term="OS" /><summary type="html"><![CDATA[CPU Scheduling 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것 컴퓨터 성능과도 직결됨 프로세스들에게 CPU를 제대로 배분하지 못한다면 당장 급하게 실행되는게 실행되지 못하거나, 급하지 않은 프로세스들만 실행 되는 등의 무질서한 상태가 발생할 수 있음]]></summary></entry><entry><title type="html">프로세스와 스레드</title><link href="http://localhost:4000/os/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C/" rel="alternate" type="text/html" title="프로세스와 스레드" /><published>2024-01-02T00:00:00+09:00</published><updated>2024-01-02T00:00:00+09:00</updated><id>http://localhost:4000/os/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%20%EC%8A%A4%EB%A0%88%EB%93%9C</id><content type="html" xml:base="http://localhost:4000/os/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C/"><![CDATA[<h2 id="process">Process</h2>
<ul>
  <li>프로그램은 실행되기 전까지는 보조기억장치에 있는 데이터 덩어리일 뿐</li>
  <li>프로그램을 메모리에 적재하고 실행되는 순간 프로그램은 프로세스가 됨</li>
  <li>Foreground Process: 사용자가 보는 앞에서 실행되는 프로세스</li>
  <li>Background Process: 사용자가 보지 못하는 뒤에서 실행되는 프로세스</li>
  <li>백그라운드 프로세스 중에서 사용자와 직접 상호작용할 수 있는 프로세스도 있지만 상호작용없이 정해진 일만 수행하는 프로세스도 있음</li>
  <li>Unix 체계에서는 이것을 <strong>Demon</strong>, Window 체계에서는 <strong>Service</strong>라고 함</li>
</ul>

<p>## Process Control Block(프로세스 제어 블록, PCB)</p>
<ul>
  <li>모든 프로세스는 실행을 위해 CPU를 필요로 하지만 CPU는 자원이 한정되어 있음</li>
  <li>때문에 OS는 빠르게 번갈아 수행되는 프로세스들의 실행 순서를 관리하고 자원을 배분함</li>
  <li>이를 위해 OS는 <strong>PCB</strong>를 사용함</li>
  <li>PCB는 프로세스와 관련된 정보를 저장하는 자료 구조</li>
  <li>PCB는 프로세스를 식별하기위해 꼭 필요한 정보들이 저장됨</li>
  <li>PCB는 커널 영역에 생성됨</li>
  <li>PCB는 프로세스 생성 시에 만들어지고 실행이 끝나면 폐기됨</li>
</ul>

<p>### PCB에 담기는 정보 (OS마다 차이가 있음)</p>
<ol>
  <li>프로세스 ID (PID)
    <ul>
      <li>프로세스를 식별하기 위해 부여하는 고유번호</li>
      <li>같은 일을 수행하는 프로그램이라도 두 번 실행하면 PID가 다른 두 개의 프로세스가 생성됨</li>
    </ul>
  </li>
  <li>레지스터 값
    <ul>
      <li>프로세스는 자신의 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원함</li>
      <li>그래야만 이전까지 진행했던 작업들을 이어서 실행할 수 있음</li>
    </ul>
  </li>
  <li>프로세스 상태</li>
  <li>스케줄링 정보</li>
  <li>매모리 관리 정보</li>
  <li>사용한 파일과 입출력장치 목록</li>
</ol>

<h2 id="context-switching문맥-교환">Context Switching(문맥 교환)</h2>
<ul>
  <li></li>
</ul>

<h2 id="reference">Reference</h2>
<p><a href="">혼자 공부하는 컴퓨터구조</a></p>]]></content><author><name>ChanHyuk</name><email>whk1140@gmail.com</email></author><category term="OS" /><summary type="html"><![CDATA[Process 프로그램은 실행되기 전까지는 보조기억장치에 있는 데이터 덩어리일 뿐 프로그램을 메모리에 적재하고 실행되는 순간 프로그램은 프로세스가 됨 Foreground Process: 사용자가 보는 앞에서 실행되는 프로세스 Background Process: 사용자가 보지 못하는 뒤에서 실행되는 프로세스 백그라운드 프로세스 중에서 사용자와 직접 상호작용할 수 있는 프로세스도 있지만 상호작용없이 정해진 일만 수행하는 프로세스도 있음 Unix 체계에서는 이것을 Demon, Window 체계에서는 Service라고 함 ## Process Control Block(프로세스 제어 블록, PCB) 모든 프로세스는 실행을 위해 CPU를 필요로 하지만 CPU는 자원이 한정되어 있음 때문에 OS는 빠르게 번갈아 수행되는 프로세스들의 실행 순서를 관리하고 자원을 배분함 이를 위해 OS는 PCB를 사용함 PCB는 프로세스와 관련된 정보를 저장하는 자료 구조 PCB는 프로세스를 식별하기위해 꼭 필요한 정보들이 저장됨 PCB는 커널 영역에 생성됨 PCB는 프로세스 생성 시에 만들어지고 실행이 끝나면 폐기됨 ### PCB에 담기는 정보 (OS마다 차이가 있음) 프로세스 ID (PID) 프로세스를 식별하기 위해 부여하는 고유번호 같은 일을 수행하는 프로그램이라도 두 번 실행하면 PID가 다른 두 개의 프로세스가 생성됨 레지스터 값 프로세스는 자신의 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원함 그래야만 이전까지 진행했던 작업들을 이어서 실행할 수 있음 프로세스 상태 스케줄링 정보 매모리 관리 정보 사용한 파일과 입출력장치 목록 Context Switching(문맥 교환)]]></summary></entry><entry><title type="html">운영체제</title><link href="http://localhost:4000/os/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/" rel="alternate" type="text/html" title="운영체제" /><published>2024-01-01T00:00:00+09:00</published><updated>2024-01-01T00:00:00+09:00</updated><id>http://localhost:4000/os/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C</id><content type="html" xml:base="http://localhost:4000/os/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"><![CDATA[<h2 id="operatingsystemos-운영체제">OperatingSystem(OS, 운영체제)</h2>
<ul>
  <li>실행할 프로그램에 필요한 자원을 할당하고 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램</li>
  <li>운영체제도 프로그램이기 때문에 메모리에 적재되어야 함</li>
  <li>하지만 특별한 프로그램이기 때문에 항상 컴퓨터가 부팅될 때 메모리 내 Kernel Space(커널 영역)이라는 공간에 적재되 실행</li>
  <li>커널 영역을 제외한 나머지 영역을 User Space(사용자 영역)</li>
  <li>운영체제는 실행할 프로그램을 메모리에 적재하고 더 이상 실행하지 않는 프로그램을 메모리에서 삭제함</li>
  <li>응용프로그램이 올바르게 실행되도록 관리함 지속적으로 메모리 자원을 관리함</li>
  <li>운영체제가 없다면 하드웨어를 조작하는 코드 까지 개발자가 모두 직접 작성해야함</li>
  <li>실제 접하게 되는 컴퓨터의 대다수의 오류 메시지의 근원은 운영체제이므로 문제해결에 도움이 됨</li>
</ul>

<p><img src="http://localhost:4000/images/Kernel.png" alt="" /></p>

<h2 id="kernel">Kernel</h2>
<ul>
  <li>자원에 접근하고 조작하는 기능, 프로그램이 안전하게 실행되게 하는 기능, 운영체제의 핵심 서비스를 담당</li>
  <li>운영체제가 설치된 모든 기기에는 Kernel이 있음 (마치 사람의 심장과도 같음)</li>
  <li>어떤 커널을 사용하는지에 따라 실행하고 개발하는 프로그램이 하드웨어을 이용하는 양상이 달라지고 컴퓨터 전체 성능도 달라질 수 있음</li>
  <li>UI(User Interface, 사용자 인터페이스): 커널에 포함되지 않는 서비스이며 사용자가 컴퓨터와 상호작용할 수 있는 통로</li>
  <li>사용자 인터페이스 종류로는 GUI(Graphical User Interface)와 CLI(Command Line Interface)가 있음</li>
</ul>

<h2 id="dual-mode이중-모드">Dual Mode(이중 모드)</h2>
<ul>
  <li>CPU가 명령어를 실행하는 모드를 크게 사용자 모드와 커널 모드로 구분하는 방식</li>
  <li>CPU는 사용자 모드인지 커널 모드인지 플래그 레지스터 속 슈퍼바이저 플래그를 통해 알 수 있음</li>
  <li>운영체제는 응용 프로그램이 하드웨어 자원(CPU, 메모리, HDD)을 사용하려하면 오직 자신을 통해서만 접근하도록 하해서 자원을 보호함</li>
  <li>만약 응용프로그램이 하드웨어 자원들에(CPU, 메모리, HDD) 직접 접근이 가능해지면 자원이 무질서해지고 컴퓨터 전체에 악영향을 미칠 수 있음</li>
</ul>

<h3 id="user-mode사용자-모드">User Mode(사용자 모드)</h3>
<ul>
  <li>운영체제 서비스를 제공받을 수 없음</li>
  <li>일반적인 응용프로그램은 기본적으로 사용자 모드로 실행함</li>
  <li>사용자 모드로 실행중인 CPU는 입출력 명령어와 같이 하드웨어 자원에 접근하는 명령어를 실행할 수 없음</li>
</ul>

<h3 id="kernel-mode커널-모드">Kernel Mode(커널 모드)</h3>
<ul>
  <li>운영체제 서비스를 제공받을 수 있으며, 커널 영역의 코드를 실행할 수 있음</li>
  <li>CPU가 커널 모드로 명령어를 실행하면 자원에 접근하는 명령어를 비롯한 모든 명령어를 실행할 수 있음</li>
</ul>

<p><img src="http://localhost:4000/images/SystemCall.png" alt="" /></p>

<h3 id="system-call시스템-호출-소프트웨어적인-인터럽트">System Call(시스템 호출, 소프트웨어적인 인터럽트)</h3>
<ul>
  <li>사용자 모드로 실행되는 프로그램이 자원에 접근하는 운영체제 서비스를 제공받으려면 운영체제에 요청을 보내 커널 모드로 전환해야함</li>
  <li>이 때 운영체제 서비스를 제공받기 위한 요청을 시스템 호출이라고 함</li>
</ul>

<h3 id="cpu가-시스템-호출을-처리하는-과정">CPU가 시스템 호출을 처리하는 과정</h3>
<ul>
  <li>인터럽트를 처리하는 과정과 유사</li>
  <li>일반적으로 응용 프로그램은 실행 과정에서 운영체제 서비스들을 매우 빈번하게 이용함
    <ol>
      <li>시스템 호출이 발생하면 CPU는 지금까지의 작업을 백업하고</li>
      <li>커널 영역 내의 시스템 호출을 수행하는 코드(인터럽트 서비스 루틴)를 실행한 뒤</li>
      <li>다시 기존에 실행하던 응용프로그램에 복귀하여 실행을 계속해 나감</li>
    </ol>
  </li>
</ul>

<h2 id="reference">Reference</h2>
<p><a href="">혼자 공부하는 컴퓨터구조</a></p>]]></content><author><name>ChanHyuk</name><email>whk1140@gmail.com</email></author><category term="OS" /><summary type="html"><![CDATA[OperatingSystem(OS, 운영체제) 실행할 프로그램에 필요한 자원을 할당하고 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램 운영체제도 프로그램이기 때문에 메모리에 적재되어야 함 하지만 특별한 프로그램이기 때문에 항상 컴퓨터가 부팅될 때 메모리 내 Kernel Space(커널 영역)이라는 공간에 적재되 실행 커널 영역을 제외한 나머지 영역을 User Space(사용자 영역) 운영체제는 실행할 프로그램을 메모리에 적재하고 더 이상 실행하지 않는 프로그램을 메모리에서 삭제함 응용프로그램이 올바르게 실행되도록 관리함 지속적으로 메모리 자원을 관리함 운영체제가 없다면 하드웨어를 조작하는 코드 까지 개발자가 모두 직접 작성해야함 실제 접하게 되는 컴퓨터의 대다수의 오류 메시지의 근원은 운영체제이므로 문제해결에 도움이 됨]]></summary></entry><entry><title type="html">CPU 성능 향상 기법</title><link href="http://localhost:4000/computerarchitecture/CPU-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81-%EA%B8%B0%EB%B2%95/" rel="alternate" type="text/html" title="CPU 성능 향상 기법" /><published>2023-12-28T00:00:00+09:00</published><updated>2023-12-28T00:00:00+09:00</updated><id>http://localhost:4000/computerarchitecture/CPU%20%EC%84%B1%EB%8A%A5%20%ED%96%A5%EC%83%81%20%EA%B8%B0%EB%B2%95</id><content type="html" xml:base="http://localhost:4000/computerarchitecture/CPU-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81-%EA%B8%B0%EB%B2%95/"><![CDATA[<h2 id="clock클럭">Clock(클럭)</h2>
<ul>
  <li>클럭 신호가 빠르게 반복되면 CPU와 그 외의 부품들은 꼭 그런건 아니지만 일반적으로 빠른 박자로 움직임</li>
  <li>즉 클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복함</li>
  <li>클럭 속도가 높은 CPU는 일반적으로 성능이 좋고 그래서 클럭 속도는 CPU 속도 단위로 간주됨</li>
  <li>클럭 속도는 헤르츠(Hz) 단위로 측정, 1초에 클럭이 몇 번 반복되는지 나타냄 ex) 2.5GHz = 25억번</li>
  <li>클럭 속도는 고성능을 요구할 때 클럭 속도를 높이고 그렇지 않을 때는 낮추기도 함</li>
  <li>최대 클럭 속도를 강제로 끌어올릴 수 있는 데 이런 기법을 <strong>overcloking</strong>이라고 함</li>
  <li>고성능 작업을 장시간 할 경우 발열 문제가 심각해짐</li>
</ul>

<h2 id="core">Core</h2>
<ul>
  <li>CPU에서 명령어를 실행하는 부품</li>
  <li>클럭 속도를 높여서 CPU 성능을 올리는 방법에는 한계가 있음</li>
  <li>그래서 현실적인 방법으로 CPU의 Core나 Thread를 늘리는 방법이 있음 ex) 8코어: 명령어를 실행하는 부품인 Core가 8개 있는 것</li>
  <li>Core가 하나만 있는것은 SingleCore, 2개 이상 여러개가 있는것을 MultiCore</li>
  <li>Core가 아무리 많아도 적절하게 명령어가 분배되지 않는다면 연산 속도가 증가 하지 않음</li>
  <li>또한 작업량에 비해 Core수가 지나치게 많아도 유의미한 성능 변화가 없음</li>
</ul>

<h2 id="thread">Thread</h2>
<ul>
  <li>사전적인 의미로 ‘실행 흐름의 단위’</li>
</ul>

<h3 id="하드웨어적-스레드--logical-processor논리-프로세서">하드웨어적 스레드 / Logical Processor(논리 프로세서)</h3>
<ul>
  <li>CPU에서 사용</li>
  <li>논리 프로세서: 실제 프로세서의 갯수는 아니지만 메모리가 실행되고 있는 프로그램이 몇개 인가 하드웨어 스레드 개수만큼 있음</li>
  <li>하나의 코어가 동시에 처리하는 명령어 단위</li>
  <li>하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 MultiThread라고 함</li>
  <li>Hyper-Threading: Intel사의 MultiThread 기술</li>
  <li>가장 큰 핵심은 레지스터</li>
  <li>하나의 코어로 여러 명령어를 동시에 처리할 경우 하나의 명령어를 처리하기 위해 꼭 필요한 레지스터를 여러개를 가지면 됨
    <ul>
      <li>프로그램 카운터</li>
      <li>스택 포인터</li>
      <li>데이터 버퍼 레지스터</li>
      <li>데이터 주소 레지스터</li>
    </ul>
  </li>
</ul>

<h3 id="소프트웨어적-스레드">소프트웨어적 스레드</h3>
<ul>
  <li>프로그램에서 사용</li>
  <li>1코어 1스레드 CPU도 <strong>여러개의 소프트웨어적 스레드</strong>를 만들 수 있음</li>
  <li>1코어 1스레드는 실제로 동시에 작업하는게 아닌 매우 빠른속도로 번갈아 가면서 실행하기 때문에 동시에 작업하는것처럼 보임</li>
  <li>하나의 프로그램에서 독립적으로 실행되는 단위</li>
  <li>하나의 프로그램에서 한개씩 실행할 수 있지만 여러 스레드를 사용할 경우 여러 부분을 동시에 실행할 수도 있음</li>
</ul>

<p><img src="http://localhost:4000/images/CoreThread.png" alt="" />
<strong>멀티코어 프로세서</strong>: 명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 두 개 이상 있는 CPU
<strong>멀티스레드 프로세서</strong>: 하나의 코어로 여러개의 명령어를 동시에 실행할 수 있는 CPU</p>

<h2 id="ilpinstruction-level-parallelism-명령어-병렬-처리-기법">ILP(Instruction-Level Parallelism, 명령어 병렬 처리 기법)</h2>
<ul>
  <li>빠른 CPU를 만들기 위해 높은 클럭속도, 코어와 스레드의 숫자도 중요하지만 CPU가 놀지 않고 효율적으로 작동하게 만드는것도 중요</li>
</ul>

<h3 id="instruction-pipelining명령어-파이프라이닝">Instruction Pipelining(명령어 파이프라이닝)</h3>
<ul>
  <li>명령어 처리 과정을 클럭 단위로 나누면 (이 단계가 명확하게 정답은 아님, 전공서마다 단계를 나누는게 다르기도 함)
    <ol>
      <li>Instruction Fetch(명령어 인출)</li>
      <li>Instruction Decode(명령어 해석)</li>
      <li>Execute Instruction(명령어 실행)</li>
      <li>Write Back(결과 저장)</li>
    </ol>
  </li>
  <li>동시에 여러 개의 명령어를 겹처 실행하는 기법</li>
  <li>중요한 것은 단계만 겹치지 않는다면 <strong>각 단계를 동시에 실행할 수 있음</strong></li>
  <li>ex) A라는 명령어가 인출을 하고 있을 때 B명령어는 해석을 할 수 있고 C명령어는 실행할 수 있음</li>
  <li>마치 공장 생산 라인과 같음</li>
  <li>높은 성능을 가져오지만 특정 상황에서 성능 향상에 실패하는 경우도 있음(Pipeline Hazard, 파이프라인 위험)</li>
</ul>

<h2 id="pipeline-hazard파이프라인-위험">Pipeline Hazard(파이프라인 위험)</h2>
<ol>
  <li>Data Hazard(데이터 위험)
    <ul>
      <li>명령어 간 ‘데이터 의존성’에 의해 발생</li>
      <li>ex) 명령어1: R1 &lt;- R2 + R3 // R2 레지스터 값과 R3 레지스터 값을 더한 값을 R1에 저장</li>
      <li>ex) 명령어2: R4 &lt;- R1 + R5 // R1 레저스터 값과 R5 레지스터 값을 더한 값을 R4에 저장
명령어 1을 실행하고 결과값이 저장되고 나서 명령어 2를 실행해야 함
명령어 1의 결과값이 인출되기 전에 명령어 2를 실행할 경우 예기치 못한 결과값이 나올 수 있음(R2는 R1 값이 꼭 필요하므로)
이런 상황을 명령어 2는 명령어 1의 데이터에 의존한다고 함
이처럼 의존적인 두 명령어를 무작정 동시에 실행할 경우 제대로 작동하지 않을 수 있음</li>
    </ul>
  </li>
  <li>Control Hazard(제어 위험)
    <ul>
      <li>분기 등으로 <strong>프로그램 카운터의 예기치못한 변화</strong>에 의해 발생</li>
      <li>일반적으로 프로그램 카운터는 <strong>현재 실행중인 명령어의 다음 주소</strong>로 갱신됨</li>
      <li>하지만 분기에 의해 실행 흐름이 바뀌어 변화가 생긴다면 파이프라인에 미리 가지고 와서 처리중이던 명령어들이 쓸모 없어질 수 있음</li>
      <li>이를 위해 사용하는 기술이 breanch prediction(분기 예측), 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술</li>
    </ul>
  </li>
  <li>Structural Hazard(구조적 위험) / Resource Hazard(자원 위험)
    <ul>
      <li>명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같이 CPU를 사용하려 할 때</li>
    </ul>
  </li>
</ol>

<h2 id="superscalar슈퍼스칼라">SuperScalar(슈퍼스칼라)</h2>
<ul>
  <li>오늘날 대부분의 CPU는 여러개의 파이프라인을 사용</li>
  <li>이론적으로는 파이프라인 개수에 비례해서 프로그램 처리 속도가 빨라져야 되지만, 파이프라인 위험 때문에 개수에 비례해서 빨라지지 않음</li>
  <li>이 때문에 슈퍼스칼라는 파이프라인 위험을 방지하기 위해 고도로 설계되어야 함</li>
</ul>

<h2 id="reference">Reference</h2>
<p><a href="">혼자 공부하는 컴퓨터구조</a></p>]]></content><author><name>ChanHyuk</name><email>whk1140@gmail.com</email></author><category term="ComputerArchitecture" /><summary type="html"><![CDATA[Clock(클럭) 클럭 신호가 빠르게 반복되면 CPU와 그 외의 부품들은 꼭 그런건 아니지만 일반적으로 빠른 박자로 움직임 즉 클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복함 클럭 속도가 높은 CPU는 일반적으로 성능이 좋고 그래서 클럭 속도는 CPU 속도 단위로 간주됨 클럭 속도는 헤르츠(Hz) 단위로 측정, 1초에 클럭이 몇 번 반복되는지 나타냄 ex) 2.5GHz = 25억번 클럭 속도는 고성능을 요구할 때 클럭 속도를 높이고 그렇지 않을 때는 낮추기도 함 최대 클럭 속도를 강제로 끌어올릴 수 있는 데 이런 기법을 overcloking이라고 함 고성능 작업을 장시간 할 경우 발열 문제가 심각해짐]]></summary></entry><entry><title type="html">Command</title><link href="http://localhost:4000/computerarchitecture/Command/" rel="alternate" type="text/html" title="Command" /><published>2023-12-22T00:00:00+09:00</published><updated>2023-12-22T00:00:00+09:00</updated><id>http://localhost:4000/computerarchitecture/Command</id><content type="html" xml:base="http://localhost:4000/computerarchitecture/Command/"><![CDATA[<h2 id="high-level-programming-language고급언어">high-level Programming language(고급언어)</h2>
<ul>
  <li>사람이 이해하기 쉽게 만들어진 언어</li>
  <li>대부분의 프로그래밍 언어</li>
  <li>고급언어에서 저급언어로 변환될때 크게 2가지 방식이 있는데 <strong>컴파일 방식</strong>과 <strong>인터프리터 방식</strong>이 있음</li>
</ul>

<h2 id="low-level-programming-language저급언어">low-level Programming language(저급언어)</h2>
<ul>
  <li>컴퓨터가 직접 이해하고 실행할 수 있는 언어</li>
  <li>기계어와 어셈블리어가 있음</li>
  <li>하드웨어와 밀접하게 맞닿은 프로그램을 개발하는 임베디드 개발자, 게임 개발자, 보안 솔루션 개발자, 시스템 해커 등에서 어셈블리어를 많이 사용</li>
  <li>어셈블리어를 읽으면 컴퓨터가 프로그램을 어떤 과정으로 실행하는지 어떤 절차로 작동하는지 근본적인 단계부터 추적하고 관찰할 수 있음</li>
  <li>어셈블리어는 CPU마다 컴파일러의 종류마다 다를 수 있음</li>
</ul>

<p><br /></p>

<h2 id="컴파일-언어">컴파일 언어</h2>
<ul>
  <li>소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어</li>
  <li>컴파일 언어로 작성된 소스 코드를 저급 언어로 변환하는 과정을 compile</li>
  <li>compile을 수행해 주는 도구를 compiler라고 함</li>
  <li>소스 코드 내에 하나의 오류라도 발견된다면 compile에 실패 함</li>
  <li>compiler를 통해 저급 언어로 변환된 코드를 object code(목적 코드) 라고 함</li>
</ul>

<h2 id="인터프리터-언어">인터프리터 언어</h2>
<ul>
  <li>소스 코드를 한줄씩 차례로 실행</li>
  <li>소스 코드를 한줄씩 저급 언어로 변환해주는 도구를 interprter라고 함</li>
  <li>중간에 오류가 있어도 오류가 있기 전까지 수행함</li>
  <li>소스 코드 전체를 저급 언어로 변환하는 시간이 필요 없음</li>
  <li>인터프리터 언어는 컴파일 언어보다 느린데 한줄 한줄씩 저급 언어로 해석하며 실행해야 하기 때문</li>
</ul>

<h3 id="컴파일-언어와-인터프리터-언어의-구분">컴파일 언어와 인터프리터 언어의 구분</h3>
<ul>
  <li>C나 C++처럼 명확하게 구분하는 언어도 있지만 많은 언어들이 컴파일 방식과 인터프리터 방식이 모호한 경우가 많음</li>
  <li>인터프리터 언어가 컴파일을 하지 않거나 불가능한것도 아니며 Java의 경우 컴파일과 인터프리트를 동시에 수행함</li>
</ul>

<h3 id="목적-파일-실행-파일">목적 파일, 실행 파일</h3>
<ul>
  <li>텍스트로 이루어진 파일을 텍스트 파일, 이미지로 이루어진 파일을 이미지 파일이라 하는것처럼</li>
  <li>목적 코드로 이루어진 파일을 <strong>목적 파일</strong>, 실행 코드로 이루어진 파일을 <strong>실행 파일</strong>이라고 함</li>
  <li>목적 코드는 컴퓨터가 이해하는 저급언어이고, 목적 파일 -&gt; 실행 파일이 되기 위해서는 <strong>Linking(링킹)</strong>이라는 작업을 거쳐야 됨</li>
</ul>

<p><br /></p>

<h2 id="명령어의-구조">명령어의 구조</h2>
<p><img src="http://localhost:4000/images/commandField.png" alt="" /></p>
<ul>
  <li>명령어는 operation code(연산 코드)와 operand(피연산자) 구조로 되어 있음</li>
  <li>색이 입혀진 필드 값, <strong>명령어가 수행할 연산</strong>을 operation code 또는 operation field 라고 함</li>
  <li>연산에 사용할 데이터, 또는 <strong>연산에 사용할 데이터가 저장된 위치</strong>를 operand, 또는 operand field라고 함</li>
</ul>

<h3 id="operation-code연산-코드">Operation Code(연산 코드)</h3>
<ul>
  <li>명령어의 종류와 내용은 CPU마다 다르기 때문에 연산 코드도 CPU마다 다름</li>
  <li>연산 코드의 종류가 많지만 기본적으로 4가지가 있음
    <ul>
      <li>데이터 전송</li>
      <li>산술/논리 연산</li>
      <li>제어 흐름 변경</li>
      <li>입출력 제어</li>
    </ul>
  </li>
</ul>

<h3 id="operand-field">Operand Field</h3>
<ul>
  <li>숫자나 문자 같은 데이터나 메모리, 레지스터 주소가 있음</li>
  <li>하나도 없을 수 있고 한 개만 있을 수 있고 여러개가 있을 수 있음
    <ul>
      <li>하나도 없는 경우 0-주소 명령어, 한 개만 있을 경우 1-주소 명령어, 2개가 있을 경우 2-주소 명령어</li>
    </ul>
  </li>
  <li>대부분의 경우 직접적으로 데이터를 명시하기 보다는 메모리 주소나 레지스터 이름이 담김</li>
</ul>

<p><br /></p>

<h2 id="addressing-mode주소-지정-방식">Addressing Mode(주소 지정 방식)</h2>
<p><img src="http://localhost:4000/images/addressingMode.png" alt="" /></p>
<ul>
  <li>명령어 전체 크기에서 연산 코드 필드를 제외한 나머지로 operand로 사용하게 됨</li>
  <li>나머지 중에서 2개 이상의 명령어가 있을 경우 또 나눠서 operand의 값을 넣을 수 있음</li>
  <li>예를 들어 그림과 같이 명령어의 전체 크기가 16비트, 연산 코드가 4비트일 때 2-주소 명령어는 필드당 6bit</li>
  <li>즉 하나의 operand field로 정보를 표현할 수 있는 가짓수는 2의 6승인 32개 밖에 되지 않음</li>
  <li>하지만 operand field 안에 정보가 아닌 메모리 주소가 담긴다면 표현할 수 있는 데이터 크기는 메모리 주소에 저장할 수 있는 공간만큼 커짐</li>
</ul>

<h3 id="immediate-addressing-mode즉시-주소-지정-방식">Immediate Addressing Mode(즉시 주소 지정 방식)</h3>
<p><img src="http://localhost:4000/images/immediateAddressingMode.png" alt="" /></p>
<ul>
  <li>연산에 사용할 데이터를 operand field에 직접 명시함</li>
  <li>가장 간단한 지정 방식이며 표현할 수 있는 데이터 크기가 작음</li>
  <li>하지만 연산에 사용할 메모리나 레지스터로 부터 찾는 과정이 없기 때문에 빠름</li>
</ul>

<h3 id="direct-addressing-mode직접-주소-지정-방식">Direct Addressing Mode(직접 주소 지정 방식)</h3>
<p><img src="http://localhost:4000/images/directAddressingMode.png" alt="" /></p>
<ul>
  <li>operand field에 유효 주소를 직접적으로 명시하는 방법</li>
  <li>즉시 주소 방식보다는 데이터 크기가 커졌지만 여전히 operand field 길이 만큼 유효 주소에 제한이 생길 수 있음</li>
</ul>

<h3 id="indirect-addressing-mode간접-주소-지정-방식">Indirect Addressing Mode(간접 주소 지정 방식)</h3>
<p><img src="http://localhost:4000/images/indirectAddressingMode.png" alt="" /></p>
<ul>
  <li>유효의 주소의 주소를 operand field에 명시</li>
  <li>유효 주소의 범위가 넓어짐</li>
  <li>하지만 두 번의 메모리 접근이 필요하기 때문에 느린 방식</li>
  <li><strong>CPU가 Memory에서 값을 찾는 시간은 상대적으로 오래 걸림, 때문에 메모리 접근을 최소화 하는것이 좋음</strong></li>
</ul>

<h3 id="register-addressing-mode레지스터-주소-지정-방식">Register Addressing Mode(레지스터 주소 지정 방식)</h3>
<p><img src="http://localhost:4000/images/registerAddressingMode.png" alt="" /></p>
<ul>
  <li>직접 주소 지정 방식과 비슷함. 데이터를 저장한 레지스터를 operand field에 직접 명시</li>
  <li>CPU 외부에 있는 메모리에 접근하는것 보다 내부에 있는 레지스터에 접근하는것이 빠름</li>
</ul>

<h3 id="register-indirect-addressing-mode레지스터-간접-주소-지정-방식">Register Indirect Addressing Mode(레지스터 간접 주소 지정 방식)</h3>
<p><img src="http://localhost:4000/images/registerIndirectAddressingMode.png" alt="" /></p>
<ul>
  <li>연산에 사용할 데이터를 메모리에 저장하고 메모리의 유효 주소를 레지스터에 저장한 다음 그 레지스터를 operand field에 명시</li>
  <li>간접 주소 지정 방식과 비슷하지만 메모리의 접근 횟수가 한 번으로 줄어드는 장점이 있음</li>
</ul>

<h2 id="reference">Reference</h2>
<p><a href="">혼자 공부하는 컴퓨터구조</a></p>]]></content><author><name>ChanHyuk</name><email>whk1140@gmail.com</email></author><category term="ComputerArchitecture" /><summary type="html"><![CDATA[high-level Programming language(고급언어) 사람이 이해하기 쉽게 만들어진 언어 대부분의 프로그래밍 언어 고급언어에서 저급언어로 변환될때 크게 2가지 방식이 있는데 컴파일 방식과 인터프리터 방식이 있음]]></summary></entry><entry><title type="html">Data</title><link href="http://localhost:4000/computerarchitecture/Data/" rel="alternate" type="text/html" title="Data" /><published>2023-12-18T00:00:00+09:00</published><updated>2023-12-18T00:00:00+09:00</updated><id>http://localhost:4000/computerarchitecture/Data</id><content type="html" xml:base="http://localhost:4000/computerarchitecture/Data/"><![CDATA[<h2 id="정보-단위">정보 단위</h2>
<ul>
  <li>0과 1을 나타내는 가장 작은 정보의 단위인 bit</li>
  <li>n 비트로 2ⁿ가지의 정보 표현 가능</li>
  <li>프로그램은 수많은 bit로 이루어져 있음</li>
</ul>

<table>
  <thead>
    <tr>
      <th>단위</th>
      <th>전 단위</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1btye</td>
      <td>8bit</td>
    </tr>
    <tr>
      <td>1kB</td>
      <td>1,000byte</td>
    </tr>
    <tr>
      <td>1MB</td>
      <td>1,000kB</td>
    </tr>
    <tr>
      <td>1GM</td>
      <td>1,000MB</td>
    </tr>
    <tr>
      <td>1TB</td>
      <td>1,000GM</td>
    </tr>
  </tbody>
</table>

<h3 id="word워드">word(워드)</h3>
<ul>
  <li>CPU가 한 번에 처리할 수 있는 데이터 크기를 말함</li>
  <li>word의 절반 크기를 half word, 1배 크기를 full word, 2배 크기를 double word 라고 함</li>
  <li>CPU마다 처리할 수 있는 양이 다르지만 대부분 word 크기는 32bit와 64bit</li>
</ul>

<h2 id="binary이진법">Binary(이진법)</h2>
<ul>
  <li>0과 1만으로 숫자를 표현함</li>
  <li>십진수와 숫자가 똑같을 경우가 많아 혼동을 예방하기 위해
    <ul>
      <li>아래첨자 ₂를 붙이거나 ex) 1000(₂), 주로 수학적으로 표기할 때</li>
      <li>이진수 앞에 0b를 붙임 ex) 0b1000, 주로 코드상에서 표기할 때</li>
    </ul>
  </li>
  <li>십진수는 - 부호를 붙이지만 이진수는 0과 1만 이해할 수 있으므로 부호를 붙이는게 아닌 다른 방식으로 음수를 표현 해야 함</li>
</ul>

<h3 id="ex-1101의-음수를-구할-때">ex) 1101(₂)의 음수를 구할 때</h3>
<ol>
  <li>0100 : 모든 0과 1을 뒤집음 (1의 보수)</li>
  <li>0101 : 뒤집은 수에서 1을 더함 (2의 보수, 1101(₂)의 음수)</li>
  <li>1101(₂)의 음수는 0101이 나왔는데 이것을 증명하기 위해서 0101(₂)을 음수를 구하면 1101(₂)가 나옴</li>
</ol>

<h3 id="음수-양수-구별">음수 양수 구별</h3>
<ul>
  <li>위와 같이 0101(₂)은 이진수 0101인지 1101(₂)의 음수인지 구별할 수 없음</li>
  <li>그래서 flag를 사용함</li>
</ul>

<h3 id="2의-보수-한계">2의 보수 한계</h3>
<ul>
  <li>0000을 음수로 표현하면 0000 -&gt; 1111 -&gt; 10000, 결과가 다른 값이 출력</li>
  <li>2의 3제곱인 1000(₂) 음수로 표현하면 1000 -&gt; 0111 -&gt; 1000, 똑같은 값이 출력</li>
</ul>

<h2 id="hexadecimal십육진법">Hexadecimal(십육진법)</h2>
<ul>
  <li>이진법은 숫자의 길이가 너무 길어진다는 단점이 있음</li>
  <li>16진법은 15에서 16을 넘어가는 시점에서 자리올림을 함</li>
  <li>A: 10, B: 11, C: 12, D: 13, E: 14, F: 15로 표기
    <ul>
      <li>아래첨자 16을 붙이거나 ex) 11(₁₆)</li>
      <li>16진수 앞에 0x를 붙여 구분 ex) 0x11</li>
    </ul>
  </li>
  <li><strong>16진수를 사용하는 이유</strong>: 이진수와 십진수를 서로 변환하는것보다 이진수와 십육진수를 서로 변환하는것이 쉽기 때문</li>
</ul>

<h3 id="16진수---2진수-변환">16진수 -&gt; 2진수 변환</h3>
<ul>
  <li>16진수 하나를 2진수로 표현하려면 4개의 bit가 필요함, 2⁴ = 16 이기 때문</li>
  <li>16진수 하나하나를 각자 2진수로 바꾼다음에 그대로 이어붙이면 됨</li>
</ul>

<p>ex) 1A2B(₁₆)
<br />
1 -&gt; 0001, A -&gt; 1010, 2 -&gt; 0010, B -&gt; 1011
0001101000101011(₂)</p>

<h3 id="2진수---16진수-변환">2진수 -&gt; 16진수 변환</h3>
<ul>
  <li>반대의 경우도 마찬가지로 2진수를 4개씩 끊고 16진수로 바꾼다음 그대로 이어붙이면 됨</li>
</ul>

<p>ex) 10101101(₂)
<br />
1010 -&gt; A, 1101 -&gt; D
AD(₁₆)</p>

<h2 id="문자-집합">문자 집합</h2>
<ul>
  <li>character set(문자 집합): 컴퓨터가 인식하고 표현할 수 있는 문자의 모음</li>
  <li>character Encoding(문자 인코딩): 문자 집합에 있는 문자를 Encoding 과정을 거쳐 컴퓨터가 이해할 수 있는 0과 1로 이루어진 문자 코드가 됨</li>
  <li>character Decoding(문자 디코딩): 반대로 컴퓨터가 이해할 수 있는 0과 1로 이루어진 문자코드를 사람이 읽을 수 있는 문자로 변환하는 과정</li>
</ul>

<h2 id="ascii아스키-코드">ASCII(아스키 코드)</h2>
<ul>
  <li>초창기 문자 집합 중 하나로 영어, 숫자, 일부 특수문자 포함</li>
  <li>하나의 아스키 문자를 위해 8bit(1byte)를 사용하는데 1bit는 Parity bit로 오류 검출을 위해 사용됨</li>
  <li>때문에 실질적으로 7bit로 표현할 수 있고 7비트로 표현할 수 있는 정보의 가짓수는 128개</li>
</ul>

<h2 id="euc-kr">EUC-KR</h2>
<ul>
  <li>한글 전용 인코딩, 한글 단어 하나에 2byte 크기의 코드 부여</li>
  <li>완성형 인코딩으로 초성, 중성, 종성의 조합으로 이루어진 하나의 완성된 글자에 고유한 코드를 부여</li>
  <li>2350개 정도의 한글을 표현할 수 있지만 부족함</li>
</ul>

<h2 id="unicode유니코드">Unicode(유니코드)</h2>
<ul>
  <li>대부부의 나라의 문자, 특수문자, 이모티콘 까지 코드로 표현할 수 있는 통일된 문자 집합</li>
  <li>글자에 부여된 값 자체를 인코딩된 값으로 정하지 않고 값을 다양한 방법으로 인코딩 함</li>
  <li>종류로는 UTF-8, UTF-16, UTF-32 등이 있음 각각 인코딩 하는 방식</li>
  <li>가장 대중적으로 UTF-8을 사용함</li>
</ul>

<h2 id="reference">Reference</h2>
<p><a href="">혼자 공부하는 컴퓨터구조</a></p>]]></content><author><name>ChanHyuk</name><email>whk1140@gmail.com</email></author><category term="ComputerArchitecture" /><summary type="html"><![CDATA[정보 단위 0과 1을 나타내는 가장 작은 정보의 단위인 bit n 비트로 2ⁿ가지의 정보 표현 가능 프로그램은 수많은 bit로 이루어져 있음]]></summary></entry></feed>